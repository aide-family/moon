// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.0
// - protoc             v5.29.3
// source: marksman/api/v1/level.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationLevelCreateLevel = "/marksman.api.v1.Level/CreateLevel"
const OperationLevelDeleteLevel = "/marksman.api.v1.Level/DeleteLevel"
const OperationLevelGetLevel = "/marksman.api.v1.Level/GetLevel"
const OperationLevelListLevel = "/marksman.api.v1.Level/ListLevel"
const OperationLevelSelectLevel = "/marksman.api.v1.Level/SelectLevel"
const OperationLevelUpdateLevel = "/marksman.api.v1.Level/UpdateLevel"
const OperationLevelUpdateLevelStatus = "/marksman.api.v1.Level/UpdateLevelStatus"

type LevelHTTPServer interface {
	CreateLevel(context.Context, *CreateLevelRequest) (*CreateLevelReply, error)
	DeleteLevel(context.Context, *DeleteLevelRequest) (*DeleteLevelReply, error)
	GetLevel(context.Context, *GetLevelRequest) (*LevelItem, error)
	ListLevel(context.Context, *ListLevelRequest) (*ListLevelReply, error)
	SelectLevel(context.Context, *SelectLevelRequest) (*SelectLevelReply, error)
	UpdateLevel(context.Context, *UpdateLevelRequest) (*UpdateLevelReply, error)
	UpdateLevelStatus(context.Context, *UpdateLevelStatusRequest) (*UpdateLevelStatusReply, error)
}

func RegisterLevelHTTPServer(s *http.Server, srv LevelHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/level", _Level_CreateLevel0_HTTP_Handler(srv))
	r.PUT("/v1/level/{uid}", _Level_UpdateLevel0_HTTP_Handler(srv))
	r.PUT("/v1/level/{uid}/status", _Level_UpdateLevelStatus0_HTTP_Handler(srv))
	r.DELETE("/v1/level/{uid}", _Level_DeleteLevel0_HTTP_Handler(srv))
	r.GET("/v1/level/{uid}", _Level_GetLevel0_HTTP_Handler(srv))
	r.GET("/v1/levels", _Level_ListLevel0_HTTP_Handler(srv))
	r.GET("/v1/levels/select", _Level_SelectLevel0_HTTP_Handler(srv))
}

func _Level_CreateLevel0_HTTP_Handler(srv LevelHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateLevelRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLevelCreateLevel)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateLevel(ctx, req.(*CreateLevelRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateLevelReply)
		return ctx.Result(200, reply)
	}
}

func _Level_UpdateLevel0_HTTP_Handler(srv LevelHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateLevelRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLevelUpdateLevel)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateLevel(ctx, req.(*UpdateLevelRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateLevelReply)
		return ctx.Result(200, reply)
	}
}

func _Level_UpdateLevelStatus0_HTTP_Handler(srv LevelHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateLevelStatusRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLevelUpdateLevelStatus)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateLevelStatus(ctx, req.(*UpdateLevelStatusRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateLevelStatusReply)
		return ctx.Result(200, reply)
	}
}

func _Level_DeleteLevel0_HTTP_Handler(srv LevelHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteLevelRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLevelDeleteLevel)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteLevel(ctx, req.(*DeleteLevelRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteLevelReply)
		return ctx.Result(200, reply)
	}
}

func _Level_GetLevel0_HTTP_Handler(srv LevelHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetLevelRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLevelGetLevel)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetLevel(ctx, req.(*GetLevelRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*LevelItem)
		return ctx.Result(200, reply)
	}
}

func _Level_ListLevel0_HTTP_Handler(srv LevelHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListLevelRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLevelListLevel)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListLevel(ctx, req.(*ListLevelRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListLevelReply)
		return ctx.Result(200, reply)
	}
}

func _Level_SelectLevel0_HTTP_Handler(srv LevelHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SelectLevelRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationLevelSelectLevel)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SelectLevel(ctx, req.(*SelectLevelRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SelectLevelReply)
		return ctx.Result(200, reply)
	}
}

type LevelHTTPClient interface {
	CreateLevel(ctx context.Context, req *CreateLevelRequest, opts ...http.CallOption) (rsp *CreateLevelReply, err error)
	DeleteLevel(ctx context.Context, req *DeleteLevelRequest, opts ...http.CallOption) (rsp *DeleteLevelReply, err error)
	GetLevel(ctx context.Context, req *GetLevelRequest, opts ...http.CallOption) (rsp *LevelItem, err error)
	ListLevel(ctx context.Context, req *ListLevelRequest, opts ...http.CallOption) (rsp *ListLevelReply, err error)
	SelectLevel(ctx context.Context, req *SelectLevelRequest, opts ...http.CallOption) (rsp *SelectLevelReply, err error)
	UpdateLevel(ctx context.Context, req *UpdateLevelRequest, opts ...http.CallOption) (rsp *UpdateLevelReply, err error)
	UpdateLevelStatus(ctx context.Context, req *UpdateLevelStatusRequest, opts ...http.CallOption) (rsp *UpdateLevelStatusReply, err error)
}

type LevelHTTPClientImpl struct {
	cc *http.Client
}

func NewLevelHTTPClient(client *http.Client) LevelHTTPClient {
	return &LevelHTTPClientImpl{client}
}

func (c *LevelHTTPClientImpl) CreateLevel(ctx context.Context, in *CreateLevelRequest, opts ...http.CallOption) (*CreateLevelReply, error) {
	var out CreateLevelReply
	pattern := "/v1/level"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLevelCreateLevel))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LevelHTTPClientImpl) DeleteLevel(ctx context.Context, in *DeleteLevelRequest, opts ...http.CallOption) (*DeleteLevelReply, error) {
	var out DeleteLevelReply
	pattern := "/v1/level/{uid}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationLevelDeleteLevel))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LevelHTTPClientImpl) GetLevel(ctx context.Context, in *GetLevelRequest, opts ...http.CallOption) (*LevelItem, error) {
	var out LevelItem
	pattern := "/v1/level/{uid}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationLevelGetLevel))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LevelHTTPClientImpl) ListLevel(ctx context.Context, in *ListLevelRequest, opts ...http.CallOption) (*ListLevelReply, error) {
	var out ListLevelReply
	pattern := "/v1/levels"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationLevelListLevel))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LevelHTTPClientImpl) SelectLevel(ctx context.Context, in *SelectLevelRequest, opts ...http.CallOption) (*SelectLevelReply, error) {
	var out SelectLevelReply
	pattern := "/v1/levels/select"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationLevelSelectLevel))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LevelHTTPClientImpl) UpdateLevel(ctx context.Context, in *UpdateLevelRequest, opts ...http.CallOption) (*UpdateLevelReply, error) {
	var out UpdateLevelReply
	pattern := "/v1/level/{uid}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLevelUpdateLevel))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *LevelHTTPClientImpl) UpdateLevelStatus(ctx context.Context, in *UpdateLevelStatusRequest, opts ...http.CallOption) (*UpdateLevelStatusReply, error) {
	var out UpdateLevelStatusReply
	pattern := "/v1/level/{uid}/status"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationLevelUpdateLevelStatus))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
