// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.0
// - protoc             v5.29.3
// source: rabbit/api/v1/webhook.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationWebhookCreateWebhook = "/rabbit.api.v1.Webhook/CreateWebhook"
const OperationWebhookDeleteWebhook = "/rabbit.api.v1.Webhook/DeleteWebhook"
const OperationWebhookGetWebhook = "/rabbit.api.v1.Webhook/GetWebhook"
const OperationWebhookListWebhook = "/rabbit.api.v1.Webhook/ListWebhook"
const OperationWebhookSelectWebhook = "/rabbit.api.v1.Webhook/SelectWebhook"
const OperationWebhookUpdateWebhook = "/rabbit.api.v1.Webhook/UpdateWebhook"
const OperationWebhookUpdateWebhookStatus = "/rabbit.api.v1.Webhook/UpdateWebhookStatus"

type WebhookHTTPServer interface {
	CreateWebhook(context.Context, *CreateWebhookRequest) (*CreateWebhookReply, error)
	DeleteWebhook(context.Context, *DeleteWebhookRequest) (*DeleteWebhookReply, error)
	GetWebhook(context.Context, *GetWebhookRequest) (*WebhookItem, error)
	ListWebhook(context.Context, *ListWebhookRequest) (*ListWebhookReply, error)
	SelectWebhook(context.Context, *SelectWebhookRequest) (*SelectWebhookReply, error)
	UpdateWebhook(context.Context, *UpdateWebhookRequest) (*UpdateWebhookReply, error)
	UpdateWebhookStatus(context.Context, *UpdateWebhookStatusRequest) (*UpdateWebhookStatusReply, error)
}

func RegisterWebhookHTTPServer(s *http.Server, srv WebhookHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/webhook/config", _Webhook_CreateWebhook0_HTTP_Handler(srv))
	r.PUT("/v1/webhook/config/{uid}", _Webhook_UpdateWebhook0_HTTP_Handler(srv))
	r.PUT("/v1/webhook/config/{uid}/status", _Webhook_UpdateWebhookStatus0_HTTP_Handler(srv))
	r.DELETE("/v1/webhook/config/{uid}", _Webhook_DeleteWebhook0_HTTP_Handler(srv))
	r.GET("/v1/webhook/config/{uid}", _Webhook_GetWebhook0_HTTP_Handler(srv))
	r.GET("/v1/webhook/configs", _Webhook_ListWebhook0_HTTP_Handler(srv))
	r.GET("/v1/webhook/configs/select", _Webhook_SelectWebhook0_HTTP_Handler(srv))
}

func _Webhook_CreateWebhook0_HTTP_Handler(srv WebhookHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateWebhookRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWebhookCreateWebhook)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateWebhook(ctx, req.(*CreateWebhookRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateWebhookReply)
		return ctx.Result(200, reply)
	}
}

func _Webhook_UpdateWebhook0_HTTP_Handler(srv WebhookHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateWebhookRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWebhookUpdateWebhook)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateWebhook(ctx, req.(*UpdateWebhookRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateWebhookReply)
		return ctx.Result(200, reply)
	}
}

func _Webhook_UpdateWebhookStatus0_HTTP_Handler(srv WebhookHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateWebhookStatusRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWebhookUpdateWebhookStatus)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateWebhookStatus(ctx, req.(*UpdateWebhookStatusRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateWebhookStatusReply)
		return ctx.Result(200, reply)
	}
}

func _Webhook_DeleteWebhook0_HTTP_Handler(srv WebhookHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteWebhookRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWebhookDeleteWebhook)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteWebhook(ctx, req.(*DeleteWebhookRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteWebhookReply)
		return ctx.Result(200, reply)
	}
}

func _Webhook_GetWebhook0_HTTP_Handler(srv WebhookHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetWebhookRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWebhookGetWebhook)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetWebhook(ctx, req.(*GetWebhookRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*WebhookItem)
		return ctx.Result(200, reply)
	}
}

func _Webhook_ListWebhook0_HTTP_Handler(srv WebhookHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListWebhookRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWebhookListWebhook)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListWebhook(ctx, req.(*ListWebhookRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListWebhookReply)
		return ctx.Result(200, reply)
	}
}

func _Webhook_SelectWebhook0_HTTP_Handler(srv WebhookHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SelectWebhookRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationWebhookSelectWebhook)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SelectWebhook(ctx, req.(*SelectWebhookRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SelectWebhookReply)
		return ctx.Result(200, reply)
	}
}

type WebhookHTTPClient interface {
	CreateWebhook(ctx context.Context, req *CreateWebhookRequest, opts ...http.CallOption) (rsp *CreateWebhookReply, err error)
	DeleteWebhook(ctx context.Context, req *DeleteWebhookRequest, opts ...http.CallOption) (rsp *DeleteWebhookReply, err error)
	GetWebhook(ctx context.Context, req *GetWebhookRequest, opts ...http.CallOption) (rsp *WebhookItem, err error)
	ListWebhook(ctx context.Context, req *ListWebhookRequest, opts ...http.CallOption) (rsp *ListWebhookReply, err error)
	SelectWebhook(ctx context.Context, req *SelectWebhookRequest, opts ...http.CallOption) (rsp *SelectWebhookReply, err error)
	UpdateWebhook(ctx context.Context, req *UpdateWebhookRequest, opts ...http.CallOption) (rsp *UpdateWebhookReply, err error)
	UpdateWebhookStatus(ctx context.Context, req *UpdateWebhookStatusRequest, opts ...http.CallOption) (rsp *UpdateWebhookStatusReply, err error)
}

type WebhookHTTPClientImpl struct {
	cc *http.Client
}

func NewWebhookHTTPClient(client *http.Client) WebhookHTTPClient {
	return &WebhookHTTPClientImpl{client}
}

func (c *WebhookHTTPClientImpl) CreateWebhook(ctx context.Context, in *CreateWebhookRequest, opts ...http.CallOption) (*CreateWebhookReply, error) {
	var out CreateWebhookReply
	pattern := "/v1/webhook/config"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationWebhookCreateWebhook))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WebhookHTTPClientImpl) DeleteWebhook(ctx context.Context, in *DeleteWebhookRequest, opts ...http.CallOption) (*DeleteWebhookReply, error) {
	var out DeleteWebhookReply
	pattern := "/v1/webhook/config/{uid}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationWebhookDeleteWebhook))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WebhookHTTPClientImpl) GetWebhook(ctx context.Context, in *GetWebhookRequest, opts ...http.CallOption) (*WebhookItem, error) {
	var out WebhookItem
	pattern := "/v1/webhook/config/{uid}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationWebhookGetWebhook))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WebhookHTTPClientImpl) ListWebhook(ctx context.Context, in *ListWebhookRequest, opts ...http.CallOption) (*ListWebhookReply, error) {
	var out ListWebhookReply
	pattern := "/v1/webhook/configs"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationWebhookListWebhook))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WebhookHTTPClientImpl) SelectWebhook(ctx context.Context, in *SelectWebhookRequest, opts ...http.CallOption) (*SelectWebhookReply, error) {
	var out SelectWebhookReply
	pattern := "/v1/webhook/configs/select"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationWebhookSelectWebhook))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WebhookHTTPClientImpl) UpdateWebhook(ctx context.Context, in *UpdateWebhookRequest, opts ...http.CallOption) (*UpdateWebhookReply, error) {
	var out UpdateWebhookReply
	pattern := "/v1/webhook/config/{uid}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationWebhookUpdateWebhook))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *WebhookHTTPClientImpl) UpdateWebhookStatus(ctx context.Context, in *UpdateWebhookStatusRequest, opts ...http.CallOption) (*UpdateWebhookStatusReply, error) {
	var out UpdateWebhookStatusReply
	pattern := "/v1/webhook/config/{uid}/status"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationWebhookUpdateWebhookStatus))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
