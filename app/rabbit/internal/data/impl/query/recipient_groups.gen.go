// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"github.com/aide-family/rabbit/internal/data/impl/do"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newRecipientGroup(db *gorm.DB, opts ...gen.DOOption) recipientGroup {
	_recipientGroup := recipientGroup{}

	_recipientGroup.recipientGroupDo.UseDB(db, opts...)
	_recipientGroup.recipientGroupDo.UseModel(&do.RecipientGroup{})

	tableName := _recipientGroup.recipientGroupDo.TableName()
	_recipientGroup.ALL = field.NewAsterisk(tableName)
	_recipientGroup.ID = field.NewInt64(tableName, "id")
	_recipientGroup.CreatedAt = field.NewTime(tableName, "created_at")
	_recipientGroup.UpdatedAt = field.NewTime(tableName, "updated_at")
	_recipientGroup.Creator = field.NewInt64(tableName, "creator")
	_recipientGroup.DeletedAt = field.NewField(tableName, "deleted_at")
	_recipientGroup.NamespaceUID = field.NewInt64(tableName, "namespace_uid")
	_recipientGroup.Name = field.NewString(tableName, "name")
	_recipientGroup.Metadata = field.NewField(tableName, "metadata")
	_recipientGroup.Status = field.NewInt32(tableName, "status")
	_recipientGroup.Templates = recipientGroupManyToManyTemplates{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Templates", "do.Template"),
	}

	_recipientGroup.EmailConfigs = recipientGroupManyToManyEmailConfigs{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("EmailConfigs", "do.EmailConfig"),
	}

	_recipientGroup.Webhooks = recipientGroupManyToManyWebhooks{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Webhooks", "do.WebhookConfig"),
	}

	_recipientGroup.Members = recipientGroupManyToManyMembers{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Members", "do.RecipientMember"),
	}

	_recipientGroup.fillFieldMap()

	return _recipientGroup
}

type recipientGroup struct {
	recipientGroupDo

	ALL          field.Asterisk
	ID           field.Int64
	CreatedAt    field.Time
	UpdatedAt    field.Time
	Creator      field.Int64
	DeletedAt    field.Field
	NamespaceUID field.Int64
	Name         field.String
	Metadata     field.Field
	Status       field.Int32
	Templates    recipientGroupManyToManyTemplates

	EmailConfigs recipientGroupManyToManyEmailConfigs

	Webhooks recipientGroupManyToManyWebhooks

	Members recipientGroupManyToManyMembers

	fieldMap map[string]field.Expr
}

func (r recipientGroup) Table(newTableName string) *recipientGroup {
	r.recipientGroupDo.UseTable(newTableName)
	return r.updateTableName(newTableName)
}

func (r recipientGroup) As(alias string) *recipientGroup {
	r.recipientGroupDo.DO = *(r.recipientGroupDo.As(alias).(*gen.DO))
	return r.updateTableName(alias)
}

func (r *recipientGroup) updateTableName(table string) *recipientGroup {
	r.ALL = field.NewAsterisk(table)
	r.ID = field.NewInt64(table, "id")
	r.CreatedAt = field.NewTime(table, "created_at")
	r.UpdatedAt = field.NewTime(table, "updated_at")
	r.Creator = field.NewInt64(table, "creator")
	r.DeletedAt = field.NewField(table, "deleted_at")
	r.NamespaceUID = field.NewInt64(table, "namespace_uid")
	r.Name = field.NewString(table, "name")
	r.Metadata = field.NewField(table, "metadata")
	r.Status = field.NewInt32(table, "status")

	r.fillFieldMap()

	return r
}

func (r *recipientGroup) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := r.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (r *recipientGroup) fillFieldMap() {
	r.fieldMap = make(map[string]field.Expr, 13)
	r.fieldMap["id"] = r.ID
	r.fieldMap["created_at"] = r.CreatedAt
	r.fieldMap["updated_at"] = r.UpdatedAt
	r.fieldMap["creator"] = r.Creator
	r.fieldMap["deleted_at"] = r.DeletedAt
	r.fieldMap["namespace_uid"] = r.NamespaceUID
	r.fieldMap["name"] = r.Name
	r.fieldMap["metadata"] = r.Metadata
	r.fieldMap["status"] = r.Status

}

func (r recipientGroup) clone(db *gorm.DB) recipientGroup {
	r.recipientGroupDo.ReplaceConnPool(db.Statement.ConnPool)
	r.Templates.db = db.Session(&gorm.Session{Initialized: true})
	r.Templates.db.Statement.ConnPool = db.Statement.ConnPool
	r.EmailConfigs.db = db.Session(&gorm.Session{Initialized: true})
	r.EmailConfigs.db.Statement.ConnPool = db.Statement.ConnPool
	r.Webhooks.db = db.Session(&gorm.Session{Initialized: true})
	r.Webhooks.db.Statement.ConnPool = db.Statement.ConnPool
	r.Members.db = db.Session(&gorm.Session{Initialized: true})
	r.Members.db.Statement.ConnPool = db.Statement.ConnPool
	return r
}

func (r recipientGroup) replaceDB(db *gorm.DB) recipientGroup {
	r.recipientGroupDo.ReplaceDB(db)
	r.Templates.db = db.Session(&gorm.Session{})
	r.EmailConfigs.db = db.Session(&gorm.Session{})
	r.Webhooks.db = db.Session(&gorm.Session{})
	r.Members.db = db.Session(&gorm.Session{})
	return r
}

type recipientGroupManyToManyTemplates struct {
	db *gorm.DB

	field.RelationField
}

func (a recipientGroupManyToManyTemplates) Where(conds ...field.Expr) *recipientGroupManyToManyTemplates {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a recipientGroupManyToManyTemplates) WithContext(ctx context.Context) *recipientGroupManyToManyTemplates {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a recipientGroupManyToManyTemplates) Session(session *gorm.Session) *recipientGroupManyToManyTemplates {
	a.db = a.db.Session(session)
	return &a
}

func (a recipientGroupManyToManyTemplates) Model(m *do.RecipientGroup) *recipientGroupManyToManyTemplatesTx {
	return &recipientGroupManyToManyTemplatesTx{a.db.Model(m).Association(a.Name())}
}

func (a recipientGroupManyToManyTemplates) Unscoped() *recipientGroupManyToManyTemplates {
	a.db = a.db.Unscoped()
	return &a
}

type recipientGroupManyToManyTemplatesTx struct{ tx *gorm.Association }

func (a recipientGroupManyToManyTemplatesTx) Find() (result []*do.Template, err error) {
	return result, a.tx.Find(&result)
}

func (a recipientGroupManyToManyTemplatesTx) Append(values ...*do.Template) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a recipientGroupManyToManyTemplatesTx) Replace(values ...*do.Template) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a recipientGroupManyToManyTemplatesTx) Delete(values ...*do.Template) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a recipientGroupManyToManyTemplatesTx) Clear() error {
	return a.tx.Clear()
}

func (a recipientGroupManyToManyTemplatesTx) Count() int64 {
	return a.tx.Count()
}

func (a recipientGroupManyToManyTemplatesTx) Unscoped() *recipientGroupManyToManyTemplatesTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type recipientGroupManyToManyEmailConfigs struct {
	db *gorm.DB

	field.RelationField
}

func (a recipientGroupManyToManyEmailConfigs) Where(conds ...field.Expr) *recipientGroupManyToManyEmailConfigs {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a recipientGroupManyToManyEmailConfigs) WithContext(ctx context.Context) *recipientGroupManyToManyEmailConfigs {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a recipientGroupManyToManyEmailConfigs) Session(session *gorm.Session) *recipientGroupManyToManyEmailConfigs {
	a.db = a.db.Session(session)
	return &a
}

func (a recipientGroupManyToManyEmailConfigs) Model(m *do.RecipientGroup) *recipientGroupManyToManyEmailConfigsTx {
	return &recipientGroupManyToManyEmailConfigsTx{a.db.Model(m).Association(a.Name())}
}

func (a recipientGroupManyToManyEmailConfigs) Unscoped() *recipientGroupManyToManyEmailConfigs {
	a.db = a.db.Unscoped()
	return &a
}

type recipientGroupManyToManyEmailConfigsTx struct{ tx *gorm.Association }

func (a recipientGroupManyToManyEmailConfigsTx) Find() (result []*do.EmailConfig, err error) {
	return result, a.tx.Find(&result)
}

func (a recipientGroupManyToManyEmailConfigsTx) Append(values ...*do.EmailConfig) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a recipientGroupManyToManyEmailConfigsTx) Replace(values ...*do.EmailConfig) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a recipientGroupManyToManyEmailConfigsTx) Delete(values ...*do.EmailConfig) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a recipientGroupManyToManyEmailConfigsTx) Clear() error {
	return a.tx.Clear()
}

func (a recipientGroupManyToManyEmailConfigsTx) Count() int64 {
	return a.tx.Count()
}

func (a recipientGroupManyToManyEmailConfigsTx) Unscoped() *recipientGroupManyToManyEmailConfigsTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type recipientGroupManyToManyWebhooks struct {
	db *gorm.DB

	field.RelationField
}

func (a recipientGroupManyToManyWebhooks) Where(conds ...field.Expr) *recipientGroupManyToManyWebhooks {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a recipientGroupManyToManyWebhooks) WithContext(ctx context.Context) *recipientGroupManyToManyWebhooks {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a recipientGroupManyToManyWebhooks) Session(session *gorm.Session) *recipientGroupManyToManyWebhooks {
	a.db = a.db.Session(session)
	return &a
}

func (a recipientGroupManyToManyWebhooks) Model(m *do.RecipientGroup) *recipientGroupManyToManyWebhooksTx {
	return &recipientGroupManyToManyWebhooksTx{a.db.Model(m).Association(a.Name())}
}

func (a recipientGroupManyToManyWebhooks) Unscoped() *recipientGroupManyToManyWebhooks {
	a.db = a.db.Unscoped()
	return &a
}

type recipientGroupManyToManyWebhooksTx struct{ tx *gorm.Association }

func (a recipientGroupManyToManyWebhooksTx) Find() (result []*do.WebhookConfig, err error) {
	return result, a.tx.Find(&result)
}

func (a recipientGroupManyToManyWebhooksTx) Append(values ...*do.WebhookConfig) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a recipientGroupManyToManyWebhooksTx) Replace(values ...*do.WebhookConfig) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a recipientGroupManyToManyWebhooksTx) Delete(values ...*do.WebhookConfig) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a recipientGroupManyToManyWebhooksTx) Clear() error {
	return a.tx.Clear()
}

func (a recipientGroupManyToManyWebhooksTx) Count() int64 {
	return a.tx.Count()
}

func (a recipientGroupManyToManyWebhooksTx) Unscoped() *recipientGroupManyToManyWebhooksTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type recipientGroupManyToManyMembers struct {
	db *gorm.DB

	field.RelationField
}

func (a recipientGroupManyToManyMembers) Where(conds ...field.Expr) *recipientGroupManyToManyMembers {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a recipientGroupManyToManyMembers) WithContext(ctx context.Context) *recipientGroupManyToManyMembers {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a recipientGroupManyToManyMembers) Session(session *gorm.Session) *recipientGroupManyToManyMembers {
	a.db = a.db.Session(session)
	return &a
}

func (a recipientGroupManyToManyMembers) Model(m *do.RecipientGroup) *recipientGroupManyToManyMembersTx {
	return &recipientGroupManyToManyMembersTx{a.db.Model(m).Association(a.Name())}
}

func (a recipientGroupManyToManyMembers) Unscoped() *recipientGroupManyToManyMembers {
	a.db = a.db.Unscoped()
	return &a
}

type recipientGroupManyToManyMembersTx struct{ tx *gorm.Association }

func (a recipientGroupManyToManyMembersTx) Find() (result []*do.RecipientMember, err error) {
	return result, a.tx.Find(&result)
}

func (a recipientGroupManyToManyMembersTx) Append(values ...*do.RecipientMember) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a recipientGroupManyToManyMembersTx) Replace(values ...*do.RecipientMember) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a recipientGroupManyToManyMembersTx) Delete(values ...*do.RecipientMember) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a recipientGroupManyToManyMembersTx) Clear() error {
	return a.tx.Clear()
}

func (a recipientGroupManyToManyMembersTx) Count() int64 {
	return a.tx.Count()
}

func (a recipientGroupManyToManyMembersTx) Unscoped() *recipientGroupManyToManyMembersTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type recipientGroupDo struct{ gen.DO }

type IRecipientGroupDo interface {
	gen.SubQuery
	Debug() IRecipientGroupDo
	WithContext(ctx context.Context) IRecipientGroupDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IRecipientGroupDo
	WriteDB() IRecipientGroupDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IRecipientGroupDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IRecipientGroupDo
	Not(conds ...gen.Condition) IRecipientGroupDo
	Or(conds ...gen.Condition) IRecipientGroupDo
	Select(conds ...field.Expr) IRecipientGroupDo
	Where(conds ...gen.Condition) IRecipientGroupDo
	Order(conds ...field.Expr) IRecipientGroupDo
	Distinct(cols ...field.Expr) IRecipientGroupDo
	Omit(cols ...field.Expr) IRecipientGroupDo
	Join(table schema.Tabler, on ...field.Expr) IRecipientGroupDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IRecipientGroupDo
	RightJoin(table schema.Tabler, on ...field.Expr) IRecipientGroupDo
	Group(cols ...field.Expr) IRecipientGroupDo
	Having(conds ...gen.Condition) IRecipientGroupDo
	Limit(limit int) IRecipientGroupDo
	Offset(offset int) IRecipientGroupDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IRecipientGroupDo
	Unscoped() IRecipientGroupDo
	Create(values ...*do.RecipientGroup) error
	CreateInBatches(values []*do.RecipientGroup, batchSize int) error
	Save(values ...*do.RecipientGroup) error
	First() (*do.RecipientGroup, error)
	Take() (*do.RecipientGroup, error)
	Last() (*do.RecipientGroup, error)
	Find() ([]*do.RecipientGroup, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*do.RecipientGroup, err error)
	FindInBatches(result *[]*do.RecipientGroup, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*do.RecipientGroup) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IRecipientGroupDo
	Assign(attrs ...field.AssignExpr) IRecipientGroupDo
	Joins(fields ...field.RelationField) IRecipientGroupDo
	Preload(fields ...field.RelationField) IRecipientGroupDo
	FirstOrInit() (*do.RecipientGroup, error)
	FirstOrCreate() (*do.RecipientGroup, error)
	FindByPage(offset int, limit int) (result []*do.RecipientGroup, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IRecipientGroupDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (r recipientGroupDo) Debug() IRecipientGroupDo {
	return r.withDO(r.DO.Debug())
}

func (r recipientGroupDo) WithContext(ctx context.Context) IRecipientGroupDo {
	return r.withDO(r.DO.WithContext(ctx))
}

func (r recipientGroupDo) ReadDB() IRecipientGroupDo {
	return r.Clauses(dbresolver.Read)
}

func (r recipientGroupDo) WriteDB() IRecipientGroupDo {
	return r.Clauses(dbresolver.Write)
}

func (r recipientGroupDo) Session(config *gorm.Session) IRecipientGroupDo {
	return r.withDO(r.DO.Session(config))
}

func (r recipientGroupDo) Clauses(conds ...clause.Expression) IRecipientGroupDo {
	return r.withDO(r.DO.Clauses(conds...))
}

func (r recipientGroupDo) Returning(value interface{}, columns ...string) IRecipientGroupDo {
	return r.withDO(r.DO.Returning(value, columns...))
}

func (r recipientGroupDo) Not(conds ...gen.Condition) IRecipientGroupDo {
	return r.withDO(r.DO.Not(conds...))
}

func (r recipientGroupDo) Or(conds ...gen.Condition) IRecipientGroupDo {
	return r.withDO(r.DO.Or(conds...))
}

func (r recipientGroupDo) Select(conds ...field.Expr) IRecipientGroupDo {
	return r.withDO(r.DO.Select(conds...))
}

func (r recipientGroupDo) Where(conds ...gen.Condition) IRecipientGroupDo {
	return r.withDO(r.DO.Where(conds...))
}

func (r recipientGroupDo) Order(conds ...field.Expr) IRecipientGroupDo {
	return r.withDO(r.DO.Order(conds...))
}

func (r recipientGroupDo) Distinct(cols ...field.Expr) IRecipientGroupDo {
	return r.withDO(r.DO.Distinct(cols...))
}

func (r recipientGroupDo) Omit(cols ...field.Expr) IRecipientGroupDo {
	return r.withDO(r.DO.Omit(cols...))
}

func (r recipientGroupDo) Join(table schema.Tabler, on ...field.Expr) IRecipientGroupDo {
	return r.withDO(r.DO.Join(table, on...))
}

func (r recipientGroupDo) LeftJoin(table schema.Tabler, on ...field.Expr) IRecipientGroupDo {
	return r.withDO(r.DO.LeftJoin(table, on...))
}

func (r recipientGroupDo) RightJoin(table schema.Tabler, on ...field.Expr) IRecipientGroupDo {
	return r.withDO(r.DO.RightJoin(table, on...))
}

func (r recipientGroupDo) Group(cols ...field.Expr) IRecipientGroupDo {
	return r.withDO(r.DO.Group(cols...))
}

func (r recipientGroupDo) Having(conds ...gen.Condition) IRecipientGroupDo {
	return r.withDO(r.DO.Having(conds...))
}

func (r recipientGroupDo) Limit(limit int) IRecipientGroupDo {
	return r.withDO(r.DO.Limit(limit))
}

func (r recipientGroupDo) Offset(offset int) IRecipientGroupDo {
	return r.withDO(r.DO.Offset(offset))
}

func (r recipientGroupDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IRecipientGroupDo {
	return r.withDO(r.DO.Scopes(funcs...))
}

func (r recipientGroupDo) Unscoped() IRecipientGroupDo {
	return r.withDO(r.DO.Unscoped())
}

func (r recipientGroupDo) Create(values ...*do.RecipientGroup) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Create(values)
}

func (r recipientGroupDo) CreateInBatches(values []*do.RecipientGroup, batchSize int) error {
	return r.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (r recipientGroupDo) Save(values ...*do.RecipientGroup) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Save(values)
}

func (r recipientGroupDo) First() (*do.RecipientGroup, error) {
	if result, err := r.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*do.RecipientGroup), nil
	}
}

func (r recipientGroupDo) Take() (*do.RecipientGroup, error) {
	if result, err := r.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*do.RecipientGroup), nil
	}
}

func (r recipientGroupDo) Last() (*do.RecipientGroup, error) {
	if result, err := r.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*do.RecipientGroup), nil
	}
}

func (r recipientGroupDo) Find() ([]*do.RecipientGroup, error) {
	result, err := r.DO.Find()
	return result.([]*do.RecipientGroup), err
}

func (r recipientGroupDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*do.RecipientGroup, err error) {
	buf := make([]*do.RecipientGroup, 0, batchSize)
	err = r.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (r recipientGroupDo) FindInBatches(result *[]*do.RecipientGroup, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return r.DO.FindInBatches(result, batchSize, fc)
}

func (r recipientGroupDo) Attrs(attrs ...field.AssignExpr) IRecipientGroupDo {
	return r.withDO(r.DO.Attrs(attrs...))
}

func (r recipientGroupDo) Assign(attrs ...field.AssignExpr) IRecipientGroupDo {
	return r.withDO(r.DO.Assign(attrs...))
}

func (r recipientGroupDo) Joins(fields ...field.RelationField) IRecipientGroupDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Joins(_f))
	}
	return &r
}

func (r recipientGroupDo) Preload(fields ...field.RelationField) IRecipientGroupDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Preload(_f))
	}
	return &r
}

func (r recipientGroupDo) FirstOrInit() (*do.RecipientGroup, error) {
	if result, err := r.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*do.RecipientGroup), nil
	}
}

func (r recipientGroupDo) FirstOrCreate() (*do.RecipientGroup, error) {
	if result, err := r.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*do.RecipientGroup), nil
	}
}

func (r recipientGroupDo) FindByPage(offset int, limit int) (result []*do.RecipientGroup, count int64, err error) {
	result, err = r.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = r.Offset(-1).Limit(-1).Count()
	return
}

func (r recipientGroupDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = r.Count()
	if err != nil {
		return
	}

	err = r.Offset(offset).Limit(limit).Scan(result)
	return
}

func (r recipientGroupDo) Scan(result interface{}) (err error) {
	return r.DO.Scan(result)
}

func (r recipientGroupDo) Delete(models ...*do.RecipientGroup) (result gen.ResultInfo, err error) {
	return r.DO.Delete(models)
}

func (r *recipientGroupDo) withDO(do gen.Dao) *recipientGroupDo {
	r.DO = *do.(*gen.DO)
	return r
}
