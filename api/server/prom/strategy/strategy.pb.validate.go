// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: server/prom/strategy/strategy.proto

package strategy

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	api "prometheus-manager/api"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = api.NotifyTemplateType(0)
)

// Validate checks the field values on CreateStrategyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateStrategyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateStrategyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateStrategyRequestMultiError, or nil if none found.
func (m *CreateStrategyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateStrategyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetGroupId() <= 0 {
		err := CreateStrategyRequestValidationError{
			field:  "GroupId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAlert()); l < 1 || l > 255 {
		err := CreateStrategyRequestValidationError{
			field:  "Alert",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateStrategyRequest_Alert_Pattern.MatchString(m.GetAlert()) {
		err := CreateStrategyRequestValidationError{
			field:  "Alert",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetExpr()) < 1 {
		err := CreateStrategyRequestValidationError{
			field:  "Expr",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetDuration() == nil {
		err := CreateStrategyRequestValidationError{
			field:  "Duration",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDuration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateStrategyRequestValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateStrategyRequestValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDuration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateStrategyRequestValidationError{
				field:  "Duration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetLabels()); l < 1 || l > 100 {
		err := CreateStrategyRequestValidationError{
			field:  "Labels",
			reason: "value must contain between 1 and 100 pairs, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetLabels()))
		i := 0
		for key := range m.GetLabels() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetLabels()[key]
			_ = val

			if l := utf8.RuneCountInString(key); l < 1 || l > 32 {
				err := CreateStrategyRequestValidationError{
					field:  fmt.Sprintf("Labels[%v]", key),
					reason: "value length must be between 1 and 32 runes, inclusive",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_CreateStrategyRequest_Labels_Pattern.MatchString(key) {
				err := CreateStrategyRequestValidationError{
					field:  fmt.Sprintf("Labels[%v]", key),
					reason: "value does not match regex pattern \"^[a-zA-Z0-9_]+$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			// no validation rules for Labels[key]
		}
	}

	if l := len(m.GetAnnotations()); l < 1 || l > 100 {
		err := CreateStrategyRequestValidationError{
			field:  "Annotations",
			reason: "value must contain between 1 and 100 pairs, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetAnnotations()))
		i := 0
		for key := range m.GetAnnotations() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetAnnotations()[key]
			_ = val

			if l := utf8.RuneCountInString(key); l < 1 || l > 32 {
				err := CreateStrategyRequestValidationError{
					field:  fmt.Sprintf("Annotations[%v]", key),
					reason: "value length must be between 1 and 32 runes, inclusive",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_CreateStrategyRequest_Annotations_Pattern.MatchString(key) {
				err := CreateStrategyRequestValidationError{
					field:  fmt.Sprintf("Annotations[%v]", key),
					reason: "value does not match regex pattern \"^[a-zA-Z0-9_]+$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			// no validation rules for Annotations[key]
		}
	}

	if len(m.GetAlarmPageIds()) < 1 {
		err := CreateStrategyRequestValidationError{
			field:  "AlarmPageIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_CreateStrategyRequest_AlarmPageIds_Unique := make(map[uint32]struct{}, len(m.GetAlarmPageIds()))

	for idx, item := range m.GetAlarmPageIds() {
		_, _ = idx, item

		if _, exists := _CreateStrategyRequest_AlarmPageIds_Unique[item]; exists {
			err := CreateStrategyRequestValidationError{
				field:  fmt.Sprintf("AlarmPageIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_CreateStrategyRequest_AlarmPageIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := CreateStrategyRequestValidationError{
				field:  fmt.Sprintf("AlarmPageIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetCategoryIds()) < 1 {
		err := CreateStrategyRequestValidationError{
			field:  "CategoryIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_CreateStrategyRequest_CategoryIds_Unique := make(map[uint32]struct{}, len(m.GetCategoryIds()))

	for idx, item := range m.GetCategoryIds() {
		_, _ = idx, item

		if _, exists := _CreateStrategyRequest_CategoryIds_Unique[item]; exists {
			err := CreateStrategyRequestValidationError{
				field:  fmt.Sprintf("CategoryIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_CreateStrategyRequest_CategoryIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := CreateStrategyRequestValidationError{
				field:  fmt.Sprintf("CategoryIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetAlarmLevelId() <= 0 {
		err := CreateStrategyRequestValidationError{
			field:  "AlarmLevelId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRemark()) > 255 {
		err := CreateStrategyRequestValidationError{
			field:  "Remark",
			reason: "value length must be at most 255 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetDataSourceId() <= 0 {
		err := CreateStrategyRequestValidationError{
			field:  "DataSourceId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMaxSuppress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateStrategyRequestValidationError{
					field:  "MaxSuppress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateStrategyRequestValidationError{
					field:  "MaxSuppress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxSuppress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateStrategyRequestValidationError{
				field:  "MaxSuppress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSendInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateStrategyRequestValidationError{
					field:  "SendInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateStrategyRequestValidationError{
					field:  "SendInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSendInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateStrategyRequestValidationError{
				field:  "SendInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SendRecover

	if len(errors) > 0 {
		return CreateStrategyRequestMultiError(errors)
	}

	return nil
}

// CreateStrategyRequestMultiError is an error wrapping multiple validation
// errors returned by CreateStrategyRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateStrategyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateStrategyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateStrategyRequestMultiError) AllErrors() []error { return m }

// CreateStrategyRequestValidationError is the validation error returned by
// CreateStrategyRequest.Validate if the designated constraints aren't met.
type CreateStrategyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateStrategyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateStrategyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateStrategyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateStrategyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateStrategyRequestValidationError) ErrorName() string {
	return "CreateStrategyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateStrategyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateStrategyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateStrategyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateStrategyRequestValidationError{}

var _CreateStrategyRequest_Alert_Pattern = regexp.MustCompile("^[a-zA-Z0-9_]+$")

var _CreateStrategyRequest_Labels_Pattern = regexp.MustCompile("^[a-zA-Z0-9_]+$")

var _CreateStrategyRequest_Annotations_Pattern = regexp.MustCompile("^[a-zA-Z0-9_]+$")

// Validate checks the field values on CreateStrategyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateStrategyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateStrategyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateStrategyReplyMultiError, or nil if none found.
func (m *CreateStrategyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateStrategyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return CreateStrategyReplyMultiError(errors)
	}

	return nil
}

// CreateStrategyReplyMultiError is an error wrapping multiple validation
// errors returned by CreateStrategyReply.ValidateAll() if the designated
// constraints aren't met.
type CreateStrategyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateStrategyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateStrategyReplyMultiError) AllErrors() []error { return m }

// CreateStrategyReplyValidationError is the validation error returned by
// CreateStrategyReply.Validate if the designated constraints aren't met.
type CreateStrategyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateStrategyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateStrategyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateStrategyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateStrategyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateStrategyReplyValidationError) ErrorName() string {
	return "CreateStrategyReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateStrategyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateStrategyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateStrategyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateStrategyReplyValidationError{}

// Validate checks the field values on UpdateStrategyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateStrategyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateStrategyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateStrategyRequestMultiError, or nil if none found.
func (m *UpdateStrategyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateStrategyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateStrategyRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetGroupId() <= 0 {
		err := UpdateStrategyRequestValidationError{
			field:  "GroupId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAlert()); l < 1 || l > 255 {
		err := UpdateStrategyRequestValidationError{
			field:  "Alert",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateStrategyRequest_Alert_Pattern.MatchString(m.GetAlert()) {
		err := UpdateStrategyRequestValidationError{
			field:  "Alert",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetExpr()) < 1 {
		err := UpdateStrategyRequestValidationError{
			field:  "Expr",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetDuration() == nil {
		err := UpdateStrategyRequestValidationError{
			field:  "Duration",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDuration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateStrategyRequestValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateStrategyRequestValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDuration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateStrategyRequestValidationError{
				field:  "Duration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetLabels()); l < 1 || l > 100 {
		err := UpdateStrategyRequestValidationError{
			field:  "Labels",
			reason: "value must contain between 1 and 100 pairs, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetLabels()))
		i := 0
		for key := range m.GetLabels() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetLabels()[key]
			_ = val

			if l := utf8.RuneCountInString(key); l < 1 || l > 32 {
				err := UpdateStrategyRequestValidationError{
					field:  fmt.Sprintf("Labels[%v]", key),
					reason: "value length must be between 1 and 32 runes, inclusive",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_UpdateStrategyRequest_Labels_Pattern.MatchString(key) {
				err := UpdateStrategyRequestValidationError{
					field:  fmt.Sprintf("Labels[%v]", key),
					reason: "value does not match regex pattern \"^[a-zA-Z0-9_]+$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			// no validation rules for Labels[key]
		}
	}

	if l := len(m.GetAnnotations()); l < 1 || l > 100 {
		err := UpdateStrategyRequestValidationError{
			field:  "Annotations",
			reason: "value must contain between 1 and 100 pairs, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetAnnotations()))
		i := 0
		for key := range m.GetAnnotations() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetAnnotations()[key]
			_ = val

			if l := utf8.RuneCountInString(key); l < 1 || l > 32 {
				err := UpdateStrategyRequestValidationError{
					field:  fmt.Sprintf("Annotations[%v]", key),
					reason: "value length must be between 1 and 32 runes, inclusive",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_UpdateStrategyRequest_Annotations_Pattern.MatchString(key) {
				err := UpdateStrategyRequestValidationError{
					field:  fmt.Sprintf("Annotations[%v]", key),
					reason: "value does not match regex pattern \"^[a-zA-Z0-9_]+$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			// no validation rules for Annotations[key]
		}
	}

	if len(m.GetAlarmPageIds()) < 1 {
		err := UpdateStrategyRequestValidationError{
			field:  "AlarmPageIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_UpdateStrategyRequest_AlarmPageIds_Unique := make(map[uint32]struct{}, len(m.GetAlarmPageIds()))

	for idx, item := range m.GetAlarmPageIds() {
		_, _ = idx, item

		if _, exists := _UpdateStrategyRequest_AlarmPageIds_Unique[item]; exists {
			err := UpdateStrategyRequestValidationError{
				field:  fmt.Sprintf("AlarmPageIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_UpdateStrategyRequest_AlarmPageIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := UpdateStrategyRequestValidationError{
				field:  fmt.Sprintf("AlarmPageIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetCategoryIds()) < 1 {
		err := UpdateStrategyRequestValidationError{
			field:  "CategoryIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_UpdateStrategyRequest_CategoryIds_Unique := make(map[uint32]struct{}, len(m.GetCategoryIds()))

	for idx, item := range m.GetCategoryIds() {
		_, _ = idx, item

		if _, exists := _UpdateStrategyRequest_CategoryIds_Unique[item]; exists {
			err := UpdateStrategyRequestValidationError{
				field:  fmt.Sprintf("CategoryIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_UpdateStrategyRequest_CategoryIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := UpdateStrategyRequestValidationError{
				field:  fmt.Sprintf("CategoryIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetAlarmLevelId() <= 0 {
		err := UpdateStrategyRequestValidationError{
			field:  "AlarmLevelId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRemark()) > 255 {
		err := UpdateStrategyRequestValidationError{
			field:  "Remark",
			reason: "value length must be at most 255 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetDataSourceId() <= 0 {
		err := UpdateStrategyRequestValidationError{
			field:  "DataSourceId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMaxSuppress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateStrategyRequestValidationError{
					field:  "MaxSuppress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateStrategyRequestValidationError{
					field:  "MaxSuppress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxSuppress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateStrategyRequestValidationError{
				field:  "MaxSuppress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSendInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateStrategyRequestValidationError{
					field:  "SendInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateStrategyRequestValidationError{
					field:  "SendInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSendInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateStrategyRequestValidationError{
				field:  "SendInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SendRecover

	if len(errors) > 0 {
		return UpdateStrategyRequestMultiError(errors)
	}

	return nil
}

// UpdateStrategyRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateStrategyRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateStrategyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateStrategyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateStrategyRequestMultiError) AllErrors() []error { return m }

// UpdateStrategyRequestValidationError is the validation error returned by
// UpdateStrategyRequest.Validate if the designated constraints aren't met.
type UpdateStrategyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateStrategyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateStrategyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateStrategyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateStrategyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateStrategyRequestValidationError) ErrorName() string {
	return "UpdateStrategyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateStrategyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateStrategyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateStrategyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateStrategyRequestValidationError{}

var _UpdateStrategyRequest_Alert_Pattern = regexp.MustCompile("^[a-zA-Z0-9_]+$")

var _UpdateStrategyRequest_Labels_Pattern = regexp.MustCompile("^[a-zA-Z0-9_]+$")

var _UpdateStrategyRequest_Annotations_Pattern = regexp.MustCompile("^[a-zA-Z0-9_]+$")

// Validate checks the field values on UpdateStrategyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateStrategyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateStrategyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateStrategyReplyMultiError, or nil if none found.
func (m *UpdateStrategyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateStrategyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return UpdateStrategyReplyMultiError(errors)
	}

	return nil
}

// UpdateStrategyReplyMultiError is an error wrapping multiple validation
// errors returned by UpdateStrategyReply.ValidateAll() if the designated
// constraints aren't met.
type UpdateStrategyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateStrategyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateStrategyReplyMultiError) AllErrors() []error { return m }

// UpdateStrategyReplyValidationError is the validation error returned by
// UpdateStrategyReply.Validate if the designated constraints aren't met.
type UpdateStrategyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateStrategyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateStrategyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateStrategyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateStrategyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateStrategyReplyValidationError) ErrorName() string {
	return "UpdateStrategyReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateStrategyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateStrategyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateStrategyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateStrategyReplyValidationError{}

// Validate checks the field values on BatchUpdateStrategyStatusRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *BatchUpdateStrategyStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchUpdateStrategyStatusRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BatchUpdateStrategyStatusRequestMultiError, or nil if none found.
func (m *BatchUpdateStrategyStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchUpdateStrategyStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetIds()) < 1 {
		err := BatchUpdateStrategyStatusRequestValidationError{
			field:  "Ids",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_BatchUpdateStrategyStatusRequest_Ids_Unique := make(map[uint32]struct{}, len(m.GetIds()))

	for idx, item := range m.GetIds() {
		_, _ = idx, item

		if _, exists := _BatchUpdateStrategyStatusRequest_Ids_Unique[item]; exists {
			err := BatchUpdateStrategyStatusRequestValidationError{
				field:  fmt.Sprintf("Ids[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_BatchUpdateStrategyStatusRequest_Ids_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := BatchUpdateStrategyStatusRequestValidationError{
				field:  fmt.Sprintf("Ids[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := _BatchUpdateStrategyStatusRequest_Status_NotInLookup[m.GetStatus()]; ok {
		err := BatchUpdateStrategyStatusRequestValidationError{
			field:  "Status",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := api.Status_name[int32(m.GetStatus())]; !ok {
		err := BatchUpdateStrategyStatusRequestValidationError{
			field:  "Status",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BatchUpdateStrategyStatusRequestMultiError(errors)
	}

	return nil
}

// BatchUpdateStrategyStatusRequestMultiError is an error wrapping multiple
// validation errors returned by
// BatchUpdateStrategyStatusRequest.ValidateAll() if the designated
// constraints aren't met.
type BatchUpdateStrategyStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchUpdateStrategyStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchUpdateStrategyStatusRequestMultiError) AllErrors() []error { return m }

// BatchUpdateStrategyStatusRequestValidationError is the validation error
// returned by BatchUpdateStrategyStatusRequest.Validate if the designated
// constraints aren't met.
type BatchUpdateStrategyStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchUpdateStrategyStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchUpdateStrategyStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchUpdateStrategyStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchUpdateStrategyStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchUpdateStrategyStatusRequestValidationError) ErrorName() string {
	return "BatchUpdateStrategyStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatchUpdateStrategyStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchUpdateStrategyStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchUpdateStrategyStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchUpdateStrategyStatusRequestValidationError{}

var _BatchUpdateStrategyStatusRequest_Status_NotInLookup = map[api.Status]struct{}{
	0: {},
}

// Validate checks the field values on BatchUpdateStrategyStatusReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchUpdateStrategyStatusReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchUpdateStrategyStatusReply with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BatchUpdateStrategyStatusReplyMultiError, or nil if none found.
func (m *BatchUpdateStrategyStatusReply) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchUpdateStrategyStatusReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BatchUpdateStrategyStatusReplyMultiError(errors)
	}

	return nil
}

// BatchUpdateStrategyStatusReplyMultiError is an error wrapping multiple
// validation errors returned by BatchUpdateStrategyStatusReply.ValidateAll()
// if the designated constraints aren't met.
type BatchUpdateStrategyStatusReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchUpdateStrategyStatusReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchUpdateStrategyStatusReplyMultiError) AllErrors() []error { return m }

// BatchUpdateStrategyStatusReplyValidationError is the validation error
// returned by BatchUpdateStrategyStatusReply.Validate if the designated
// constraints aren't met.
type BatchUpdateStrategyStatusReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchUpdateStrategyStatusReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchUpdateStrategyStatusReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchUpdateStrategyStatusReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchUpdateStrategyStatusReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchUpdateStrategyStatusReplyValidationError) ErrorName() string {
	return "BatchUpdateStrategyStatusReplyValidationError"
}

// Error satisfies the builtin error interface
func (e BatchUpdateStrategyStatusReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchUpdateStrategyStatusReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchUpdateStrategyStatusReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchUpdateStrategyStatusReplyValidationError{}

// Validate checks the field values on DeleteStrategyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteStrategyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteStrategyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteStrategyRequestMultiError, or nil if none found.
func (m *DeleteStrategyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteStrategyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteStrategyRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteStrategyRequestMultiError(errors)
	}

	return nil
}

// DeleteStrategyRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteStrategyRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteStrategyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteStrategyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteStrategyRequestMultiError) AllErrors() []error { return m }

// DeleteStrategyRequestValidationError is the validation error returned by
// DeleteStrategyRequest.Validate if the designated constraints aren't met.
type DeleteStrategyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteStrategyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteStrategyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteStrategyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteStrategyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteStrategyRequestValidationError) ErrorName() string {
	return "DeleteStrategyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteStrategyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteStrategyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteStrategyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteStrategyRequestValidationError{}

// Validate checks the field values on DeleteStrategyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteStrategyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteStrategyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteStrategyReplyMultiError, or nil if none found.
func (m *DeleteStrategyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteStrategyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteStrategyReplyMultiError(errors)
	}

	return nil
}

// DeleteStrategyReplyMultiError is an error wrapping multiple validation
// errors returned by DeleteStrategyReply.ValidateAll() if the designated
// constraints aren't met.
type DeleteStrategyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteStrategyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteStrategyReplyMultiError) AllErrors() []error { return m }

// DeleteStrategyReplyValidationError is the validation error returned by
// DeleteStrategyReply.Validate if the designated constraints aren't met.
type DeleteStrategyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteStrategyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteStrategyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteStrategyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteStrategyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteStrategyReplyValidationError) ErrorName() string {
	return "DeleteStrategyReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteStrategyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteStrategyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteStrategyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteStrategyReplyValidationError{}

// Validate checks the field values on BatchDeleteStrategyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchDeleteStrategyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchDeleteStrategyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchDeleteStrategyRequestMultiError, or nil if none found.
func (m *BatchDeleteStrategyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchDeleteStrategyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetIds()) < 1 {
		err := BatchDeleteStrategyRequestValidationError{
			field:  "Ids",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_BatchDeleteStrategyRequest_Ids_Unique := make(map[uint32]struct{}, len(m.GetIds()))

	for idx, item := range m.GetIds() {
		_, _ = idx, item

		if _, exists := _BatchDeleteStrategyRequest_Ids_Unique[item]; exists {
			err := BatchDeleteStrategyRequestValidationError{
				field:  fmt.Sprintf("Ids[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_BatchDeleteStrategyRequest_Ids_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := BatchDeleteStrategyRequestValidationError{
				field:  fmt.Sprintf("Ids[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return BatchDeleteStrategyRequestMultiError(errors)
	}

	return nil
}

// BatchDeleteStrategyRequestMultiError is an error wrapping multiple
// validation errors returned by BatchDeleteStrategyRequest.ValidateAll() if
// the designated constraints aren't met.
type BatchDeleteStrategyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchDeleteStrategyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchDeleteStrategyRequestMultiError) AllErrors() []error { return m }

// BatchDeleteStrategyRequestValidationError is the validation error returned
// by BatchDeleteStrategyRequest.Validate if the designated constraints aren't met.
type BatchDeleteStrategyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchDeleteStrategyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchDeleteStrategyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchDeleteStrategyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchDeleteStrategyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchDeleteStrategyRequestValidationError) ErrorName() string {
	return "BatchDeleteStrategyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatchDeleteStrategyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchDeleteStrategyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchDeleteStrategyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchDeleteStrategyRequestValidationError{}

// Validate checks the field values on BatchDeleteStrategyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchDeleteStrategyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchDeleteStrategyReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchDeleteStrategyReplyMultiError, or nil if none found.
func (m *BatchDeleteStrategyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchDeleteStrategyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BatchDeleteStrategyReplyMultiError(errors)
	}

	return nil
}

// BatchDeleteStrategyReplyMultiError is an error wrapping multiple validation
// errors returned by BatchDeleteStrategyReply.ValidateAll() if the designated
// constraints aren't met.
type BatchDeleteStrategyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchDeleteStrategyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchDeleteStrategyReplyMultiError) AllErrors() []error { return m }

// BatchDeleteStrategyReplyValidationError is the validation error returned by
// BatchDeleteStrategyReply.Validate if the designated constraints aren't met.
type BatchDeleteStrategyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchDeleteStrategyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchDeleteStrategyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchDeleteStrategyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchDeleteStrategyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchDeleteStrategyReplyValidationError) ErrorName() string {
	return "BatchDeleteStrategyReplyValidationError"
}

// Error satisfies the builtin error interface
func (e BatchDeleteStrategyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchDeleteStrategyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchDeleteStrategyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchDeleteStrategyReplyValidationError{}

// Validate checks the field values on GetStrategyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetStrategyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetStrategyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetStrategyRequestMultiError, or nil if none found.
func (m *GetStrategyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetStrategyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetStrategyRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetStrategyRequestMultiError(errors)
	}

	return nil
}

// GetStrategyRequestMultiError is an error wrapping multiple validation errors
// returned by GetStrategyRequest.ValidateAll() if the designated constraints
// aren't met.
type GetStrategyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetStrategyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetStrategyRequestMultiError) AllErrors() []error { return m }

// GetStrategyRequestValidationError is the validation error returned by
// GetStrategyRequest.Validate if the designated constraints aren't met.
type GetStrategyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetStrategyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetStrategyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetStrategyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetStrategyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetStrategyRequestValidationError) ErrorName() string {
	return "GetStrategyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetStrategyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetStrategyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetStrategyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetStrategyRequestValidationError{}

// Validate checks the field values on GetStrategyReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetStrategyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetStrategyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetStrategyReplyMultiError, or nil if none found.
func (m *GetStrategyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetStrategyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetStrategyReplyValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetStrategyReplyValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetStrategyReplyValidationError{
				field:  "Detail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetStrategyReplyMultiError(errors)
	}

	return nil
}

// GetStrategyReplyMultiError is an error wrapping multiple validation errors
// returned by GetStrategyReply.ValidateAll() if the designated constraints
// aren't met.
type GetStrategyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetStrategyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetStrategyReplyMultiError) AllErrors() []error { return m }

// GetStrategyReplyValidationError is the validation error returned by
// GetStrategyReply.Validate if the designated constraints aren't met.
type GetStrategyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetStrategyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetStrategyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetStrategyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetStrategyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetStrategyReplyValidationError) ErrorName() string { return "GetStrategyReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetStrategyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetStrategyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetStrategyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetStrategyReplyValidationError{}

// Validate checks the field values on ListStrategyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListStrategyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListStrategyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListStrategyRequestMultiError, or nil if none found.
func (m *ListStrategyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListStrategyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPage() == nil {
		err := ListStrategyRequestValidationError{
			field:  "Page",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListStrategyRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListStrategyRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListStrategyRequestValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetKeyword()) > 255 {
		err := ListStrategyRequestValidationError{
			field:  "Keyword",
			reason: "value length must be at most 255 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for GroupId

	if len(m.GetCategoryIds()) > 10 {
		err := ListStrategyRequestValidationError{
			field:  "CategoryIds",
			reason: "value must contain no more than 10 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ListStrategyRequest_CategoryIds_Unique := make(map[uint32]struct{}, len(m.GetCategoryIds()))

	for idx, item := range m.GetCategoryIds() {
		_, _ = idx, item

		if _, exists := _ListStrategyRequest_CategoryIds_Unique[item]; exists {
			err := ListStrategyRequestValidationError{
				field:  fmt.Sprintf("CategoryIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ListStrategyRequest_CategoryIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := ListStrategyRequestValidationError{
				field:  fmt.Sprintf("CategoryIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for AlarmLevelId

	if _, ok := api.Status_name[int32(m.GetStatus())]; !ok {
		err := ListStrategyRequestValidationError{
			field:  "Status",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsDeleted

	// no validation rules for StrategyId

	if len(errors) > 0 {
		return ListStrategyRequestMultiError(errors)
	}

	return nil
}

// ListStrategyRequestMultiError is an error wrapping multiple validation
// errors returned by ListStrategyRequest.ValidateAll() if the designated
// constraints aren't met.
type ListStrategyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListStrategyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListStrategyRequestMultiError) AllErrors() []error { return m }

// ListStrategyRequestValidationError is the validation error returned by
// ListStrategyRequest.Validate if the designated constraints aren't met.
type ListStrategyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListStrategyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListStrategyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListStrategyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListStrategyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListStrategyRequestValidationError) ErrorName() string {
	return "ListStrategyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListStrategyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListStrategyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListStrategyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListStrategyRequestValidationError{}

// Validate checks the field values on ListStrategyReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListStrategyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListStrategyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListStrategyReplyMultiError, or nil if none found.
func (m *ListStrategyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListStrategyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListStrategyReplyValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListStrategyReplyValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListStrategyReplyValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListStrategyReplyValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListStrategyReplyValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListStrategyReplyValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListStrategyReplyMultiError(errors)
	}

	return nil
}

// ListStrategyReplyMultiError is an error wrapping multiple validation errors
// returned by ListStrategyReply.ValidateAll() if the designated constraints
// aren't met.
type ListStrategyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListStrategyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListStrategyReplyMultiError) AllErrors() []error { return m }

// ListStrategyReplyValidationError is the validation error returned by
// ListStrategyReply.Validate if the designated constraints aren't met.
type ListStrategyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListStrategyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListStrategyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListStrategyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListStrategyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListStrategyReplyValidationError) ErrorName() string {
	return "ListStrategyReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListStrategyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListStrategyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListStrategyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListStrategyReplyValidationError{}

// Validate checks the field values on SelectStrategyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SelectStrategyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SelectStrategyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SelectStrategyRequestMultiError, or nil if none found.
func (m *SelectStrategyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SelectStrategyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPage() == nil {
		err := SelectStrategyRequestValidationError{
			field:  "Page",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SelectStrategyRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SelectStrategyRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SelectStrategyRequestValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetKeyword()) > 255 {
		err := SelectStrategyRequestValidationError{
			field:  "Keyword",
			reason: "value length must be at most 255 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := api.Status_name[int32(m.GetStatus())]; !ok {
		err := SelectStrategyRequestValidationError{
			field:  "Status",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SelectStrategyRequestMultiError(errors)
	}

	return nil
}

// SelectStrategyRequestMultiError is an error wrapping multiple validation
// errors returned by SelectStrategyRequest.ValidateAll() if the designated
// constraints aren't met.
type SelectStrategyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SelectStrategyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SelectStrategyRequestMultiError) AllErrors() []error { return m }

// SelectStrategyRequestValidationError is the validation error returned by
// SelectStrategyRequest.Validate if the designated constraints aren't met.
type SelectStrategyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SelectStrategyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SelectStrategyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SelectStrategyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SelectStrategyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SelectStrategyRequestValidationError) ErrorName() string {
	return "SelectStrategyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SelectStrategyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSelectStrategyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SelectStrategyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SelectStrategyRequestValidationError{}

// Validate checks the field values on SelectStrategyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SelectStrategyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SelectStrategyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SelectStrategyReplyMultiError, or nil if none found.
func (m *SelectStrategyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *SelectStrategyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SelectStrategyReplyValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SelectStrategyReplyValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SelectStrategyReplyValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SelectStrategyReplyValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SelectStrategyReplyValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SelectStrategyReplyValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SelectStrategyReplyMultiError(errors)
	}

	return nil
}

// SelectStrategyReplyMultiError is an error wrapping multiple validation
// errors returned by SelectStrategyReply.ValidateAll() if the designated
// constraints aren't met.
type SelectStrategyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SelectStrategyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SelectStrategyReplyMultiError) AllErrors() []error { return m }

// SelectStrategyReplyValidationError is the validation error returned by
// SelectStrategyReply.Validate if the designated constraints aren't met.
type SelectStrategyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SelectStrategyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SelectStrategyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SelectStrategyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SelectStrategyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SelectStrategyReplyValidationError) ErrorName() string {
	return "SelectStrategyReplyValidationError"
}

// Error satisfies the builtin error interface
func (e SelectStrategyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSelectStrategyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SelectStrategyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SelectStrategyReplyValidationError{}

// Validate checks the field values on ExportStrategyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExportStrategyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportStrategyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExportStrategyRequestMultiError, or nil if none found.
func (m *ExportStrategyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportStrategyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetIds()) < 1 {
		err := ExportStrategyRequestValidationError{
			field:  "Ids",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ExportStrategyRequest_Ids_Unique := make(map[uint32]struct{}, len(m.GetIds()))

	for idx, item := range m.GetIds() {
		_, _ = idx, item

		if _, exists := _ExportStrategyRequest_Ids_Unique[item]; exists {
			err := ExportStrategyRequestValidationError{
				field:  fmt.Sprintf("Ids[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ExportStrategyRequest_Ids_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := ExportStrategyRequestValidationError{
				field:  fmt.Sprintf("Ids[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ExportStrategyRequestMultiError(errors)
	}

	return nil
}

// ExportStrategyRequestMultiError is an error wrapping multiple validation
// errors returned by ExportStrategyRequest.ValidateAll() if the designated
// constraints aren't met.
type ExportStrategyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportStrategyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportStrategyRequestMultiError) AllErrors() []error { return m }

// ExportStrategyRequestValidationError is the validation error returned by
// ExportStrategyRequest.Validate if the designated constraints aren't met.
type ExportStrategyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportStrategyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportStrategyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportStrategyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportStrategyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportStrategyRequestValidationError) ErrorName() string {
	return "ExportStrategyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExportStrategyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportStrategyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportStrategyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportStrategyRequestValidationError{}

// Validate checks the field values on ExportStrategyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExportStrategyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportStrategyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExportStrategyReplyMultiError, or nil if none found.
func (m *ExportStrategyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportStrategyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	// no validation rules for FileName

	if len(errors) > 0 {
		return ExportStrategyReplyMultiError(errors)
	}

	return nil
}

// ExportStrategyReplyMultiError is an error wrapping multiple validation
// errors returned by ExportStrategyReply.ValidateAll() if the designated
// constraints aren't met.
type ExportStrategyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportStrategyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportStrategyReplyMultiError) AllErrors() []error { return m }

// ExportStrategyReplyValidationError is the validation error returned by
// ExportStrategyReply.Validate if the designated constraints aren't met.
type ExportStrategyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportStrategyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportStrategyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportStrategyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportStrategyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportStrategyReplyValidationError) ErrorName() string {
	return "ExportStrategyReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ExportStrategyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportStrategyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportStrategyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportStrategyReplyValidationError{}

// Validate checks the field values on GetStrategyNotifyObjectRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetStrategyNotifyObjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetStrategyNotifyObjectRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetStrategyNotifyObjectRequestMultiError, or nil if none found.
func (m *GetStrategyNotifyObjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetStrategyNotifyObjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetStrategyNotifyObjectRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetStrategyNotifyObjectRequestMultiError(errors)
	}

	return nil
}

// GetStrategyNotifyObjectRequestMultiError is an error wrapping multiple
// validation errors returned by GetStrategyNotifyObjectRequest.ValidateAll()
// if the designated constraints aren't met.
type GetStrategyNotifyObjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetStrategyNotifyObjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetStrategyNotifyObjectRequestMultiError) AllErrors() []error { return m }

// GetStrategyNotifyObjectRequestValidationError is the validation error
// returned by GetStrategyNotifyObjectRequest.Validate if the designated
// constraints aren't met.
type GetStrategyNotifyObjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetStrategyNotifyObjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetStrategyNotifyObjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetStrategyNotifyObjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetStrategyNotifyObjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetStrategyNotifyObjectRequestValidationError) ErrorName() string {
	return "GetStrategyNotifyObjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetStrategyNotifyObjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetStrategyNotifyObjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetStrategyNotifyObjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetStrategyNotifyObjectRequestValidationError{}

// Validate checks the field values on GetStrategyNotifyObjectReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetStrategyNotifyObjectReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetStrategyNotifyObjectReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetStrategyNotifyObjectReplyMultiError, or nil if none found.
func (m *GetStrategyNotifyObjectReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetStrategyNotifyObjectReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetStrategyNotifyObjectReplyValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetStrategyNotifyObjectReplyValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetStrategyNotifyObjectReplyValidationError{
				field:  "Detail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetNotifyObjectList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetStrategyNotifyObjectReplyValidationError{
						field:  fmt.Sprintf("NotifyObjectList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetStrategyNotifyObjectReplyValidationError{
						field:  fmt.Sprintf("NotifyObjectList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetStrategyNotifyObjectReplyValidationError{
					field:  fmt.Sprintf("NotifyObjectList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetStrategyNotifyObjectReplyMultiError(errors)
	}

	return nil
}

// GetStrategyNotifyObjectReplyMultiError is an error wrapping multiple
// validation errors returned by GetStrategyNotifyObjectReply.ValidateAll() if
// the designated constraints aren't met.
type GetStrategyNotifyObjectReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetStrategyNotifyObjectReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetStrategyNotifyObjectReplyMultiError) AllErrors() []error { return m }

// GetStrategyNotifyObjectReplyValidationError is the validation error returned
// by GetStrategyNotifyObjectReply.Validate if the designated constraints
// aren't met.
type GetStrategyNotifyObjectReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetStrategyNotifyObjectReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetStrategyNotifyObjectReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetStrategyNotifyObjectReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetStrategyNotifyObjectReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetStrategyNotifyObjectReplyValidationError) ErrorName() string {
	return "GetStrategyNotifyObjectReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetStrategyNotifyObjectReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetStrategyNotifyObjectReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetStrategyNotifyObjectReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetStrategyNotifyObjectReplyValidationError{}

// Validate checks the field values on BindStrategyNotifyObjectRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BindStrategyNotifyObjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BindStrategyNotifyObjectRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BindStrategyNotifyObjectRequestMultiError, or nil if none found.
func (m *BindStrategyNotifyObjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BindStrategyNotifyObjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := BindStrategyNotifyObjectRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNotifyObjectIds()) < 1 {
		err := BindStrategyNotifyObjectRequestValidationError{
			field:  "NotifyObjectIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_BindStrategyNotifyObjectRequest_NotifyObjectIds_Unique := make(map[uint32]struct{}, len(m.GetNotifyObjectIds()))

	for idx, item := range m.GetNotifyObjectIds() {
		_, _ = idx, item

		if _, exists := _BindStrategyNotifyObjectRequest_NotifyObjectIds_Unique[item]; exists {
			err := BindStrategyNotifyObjectRequestValidationError{
				field:  fmt.Sprintf("NotifyObjectIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_BindStrategyNotifyObjectRequest_NotifyObjectIds_Unique[item] = struct{}{}
		}

		// no validation rules for NotifyObjectIds[idx]
	}

	if len(errors) > 0 {
		return BindStrategyNotifyObjectRequestMultiError(errors)
	}

	return nil
}

// BindStrategyNotifyObjectRequestMultiError is an error wrapping multiple
// validation errors returned by BindStrategyNotifyObjectRequest.ValidateAll()
// if the designated constraints aren't met.
type BindStrategyNotifyObjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BindStrategyNotifyObjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BindStrategyNotifyObjectRequestMultiError) AllErrors() []error { return m }

// BindStrategyNotifyObjectRequestValidationError is the validation error
// returned by BindStrategyNotifyObjectRequest.Validate if the designated
// constraints aren't met.
type BindStrategyNotifyObjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindStrategyNotifyObjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindStrategyNotifyObjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindStrategyNotifyObjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindStrategyNotifyObjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindStrategyNotifyObjectRequestValidationError) ErrorName() string {
	return "BindStrategyNotifyObjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BindStrategyNotifyObjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindStrategyNotifyObjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindStrategyNotifyObjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindStrategyNotifyObjectRequestValidationError{}

// Validate checks the field values on BindStrategyNotifyObjectReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BindStrategyNotifyObjectReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BindStrategyNotifyObjectReply with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BindStrategyNotifyObjectReplyMultiError, or nil if none found.
func (m *BindStrategyNotifyObjectReply) ValidateAll() error {
	return m.validate(true)
}

func (m *BindStrategyNotifyObjectReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return BindStrategyNotifyObjectReplyMultiError(errors)
	}

	return nil
}

// BindStrategyNotifyObjectReplyMultiError is an error wrapping multiple
// validation errors returned by BindStrategyNotifyObjectReply.ValidateAll()
// if the designated constraints aren't met.
type BindStrategyNotifyObjectReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BindStrategyNotifyObjectReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BindStrategyNotifyObjectReplyMultiError) AllErrors() []error { return m }

// BindStrategyNotifyObjectReplyValidationError is the validation error
// returned by BindStrategyNotifyObjectReply.Validate if the designated
// constraints aren't met.
type BindStrategyNotifyObjectReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindStrategyNotifyObjectReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindStrategyNotifyObjectReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindStrategyNotifyObjectReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindStrategyNotifyObjectReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindStrategyNotifyObjectReplyValidationError) ErrorName() string {
	return "BindStrategyNotifyObjectReplyValidationError"
}

// Error satisfies the builtin error interface
func (e BindStrategyNotifyObjectReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindStrategyNotifyObjectReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindStrategyNotifyObjectReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindStrategyNotifyObjectReplyValidationError{}

// Validate checks the field values on TestTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestTemplateRequestMultiError, or nil if none found.
func (m *TestTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := api.NotifyTemplateType_name[int32(m.GetNotifyType())]; !ok {
		err := TestTemplateRequestValidationError{
			field:  "NotifyType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Template

	if m.GetStrategyId() <= 0 {
		err := TestTemplateRequestValidationError{
			field:  "StrategyId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TestTemplateRequestMultiError(errors)
	}

	return nil
}

// TestTemplateRequestMultiError is an error wrapping multiple validation
// errors returned by TestTemplateRequest.ValidateAll() if the designated
// constraints aren't met.
type TestTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestTemplateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestTemplateRequestMultiError) AllErrors() []error { return m }

// TestTemplateRequestValidationError is the validation error returned by
// TestTemplateRequest.Validate if the designated constraints aren't met.
type TestTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestTemplateRequestValidationError) ErrorName() string {
	return "TestTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TestTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestTemplateRequestValidationError{}

// Validate checks the field values on TestTemplateReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TestTemplateReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestTemplateReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestTemplateReplyMultiError, or nil if none found.
func (m *TestTemplateReply) ValidateAll() error {
	return m.validate(true)
}

func (m *TestTemplateReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return TestTemplateReplyMultiError(errors)
	}

	return nil
}

// TestTemplateReplyMultiError is an error wrapping multiple validation errors
// returned by TestTemplateReply.ValidateAll() if the designated constraints
// aren't met.
type TestTemplateReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestTemplateReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestTemplateReplyMultiError) AllErrors() []error { return m }

// TestTemplateReplyValidationError is the validation error returned by
// TestTemplateReply.Validate if the designated constraints aren't met.
type TestTemplateReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestTemplateReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestTemplateReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestTemplateReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestTemplateReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestTemplateReplyValidationError) ErrorName() string {
	return "TestTemplateReplyValidationError"
}

// Error satisfies the builtin error interface
func (e TestTemplateReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestTemplateReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestTemplateReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestTemplateReplyValidationError{}
