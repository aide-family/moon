// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: server/prom/strategy/group/group.proto

package group

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	api "prometheus-manager/api"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = api.Status(0)
)

// Validate checks the field values on CreateGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateGroupRequestMultiError, or nil if none found.
func (m *CreateGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := CreateGroupRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateGroupRequest_Name_Pattern.MatchString(m.GetName()) {
		err := CreateGroupRequestValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetCategoryIds() {
		_, _ = idx, item

		if item <= 0 {
			err := CreateGroupRequestValidationError{
				field:  fmt.Sprintf("CategoryIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if utf8.RuneCountInString(m.GetRemark()) > 255 {
		err := CreateGroupRequestValidationError{
			field:  "Remark",
			reason: "value length must be at most 255 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateGroupRequestMultiError(errors)
	}

	return nil
}

// CreateGroupRequestMultiError is an error wrapping multiple validation errors
// returned by CreateGroupRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateGroupRequestMultiError) AllErrors() []error { return m }

// CreateGroupRequestValidationError is the validation error returned by
// CreateGroupRequest.Validate if the designated constraints aren't met.
type CreateGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateGroupRequestValidationError) ErrorName() string {
	return "CreateGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateGroupRequestValidationError{}

var _CreateGroupRequest_Name_Pattern = regexp.MustCompile("^[a-zA-Z0-9_]+$")

// Validate checks the field values on CreateGroupReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateGroupReplyMultiError, or nil if none found.
func (m *CreateGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return CreateGroupReplyMultiError(errors)
	}

	return nil
}

// CreateGroupReplyMultiError is an error wrapping multiple validation errors
// returned by CreateGroupReply.ValidateAll() if the designated constraints
// aren't met.
type CreateGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateGroupReplyMultiError) AllErrors() []error { return m }

// CreateGroupReplyValidationError is the validation error returned by
// CreateGroupReply.Validate if the designated constraints aren't met.
type CreateGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateGroupReplyValidationError) ErrorName() string { return "CreateGroupReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateGroupReplyValidationError{}

// Validate checks the field values on UpdateGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateGroupRequestMultiError, or nil if none found.
func (m *UpdateGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateGroupRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := UpdateGroupRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateGroupRequest_Name_Pattern.MatchString(m.GetName()) {
		err := UpdateGroupRequestValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetCategoryIds() {
		_, _ = idx, item

		if item <= 0 {
			err := UpdateGroupRequestValidationError{
				field:  fmt.Sprintf("CategoryIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if utf8.RuneCountInString(m.GetRemark()) > 255 {
		err := UpdateGroupRequestValidationError{
			field:  "Remark",
			reason: "value length must be at most 255 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateGroupRequestMultiError(errors)
	}

	return nil
}

// UpdateGroupRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateGroupRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateGroupRequestMultiError) AllErrors() []error { return m }

// UpdateGroupRequestValidationError is the validation error returned by
// UpdateGroupRequest.Validate if the designated constraints aren't met.
type UpdateGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateGroupRequestValidationError) ErrorName() string {
	return "UpdateGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateGroupRequestValidationError{}

var _UpdateGroupRequest_Name_Pattern = regexp.MustCompile("^[a-zA-Z0-9_]+$")

// Validate checks the field values on UpdateGroupReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateGroupReplyMultiError, or nil if none found.
func (m *UpdateGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return UpdateGroupReplyMultiError(errors)
	}

	return nil
}

// UpdateGroupReplyMultiError is an error wrapping multiple validation errors
// returned by UpdateGroupReply.ValidateAll() if the designated constraints
// aren't met.
type UpdateGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateGroupReplyMultiError) AllErrors() []error { return m }

// UpdateGroupReplyValidationError is the validation error returned by
// UpdateGroupReply.Validate if the designated constraints aren't met.
type UpdateGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateGroupReplyValidationError) ErrorName() string { return "UpdateGroupReplyValidationError" }

// Error satisfies the builtin error interface
func (e UpdateGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateGroupReplyValidationError{}

// Validate checks the field values on BatchUpdateGroupStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchUpdateGroupStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchUpdateGroupStatusRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BatchUpdateGroupStatusRequestMultiError, or nil if none found.
func (m *BatchUpdateGroupStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchUpdateGroupStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetIds()); l < 1 || l > 100 {
		err := BatchUpdateGroupStatusRequestValidationError{
			field:  "Ids",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_BatchUpdateGroupStatusRequest_Ids_Unique := make(map[uint32]struct{}, len(m.GetIds()))

	for idx, item := range m.GetIds() {
		_, _ = idx, item

		if _, exists := _BatchUpdateGroupStatusRequest_Ids_Unique[item]; exists {
			err := BatchUpdateGroupStatusRequestValidationError{
				field:  fmt.Sprintf("Ids[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_BatchUpdateGroupStatusRequest_Ids_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := BatchUpdateGroupStatusRequestValidationError{
				field:  fmt.Sprintf("Ids[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := api.Status_name[int32(m.GetStatus())]; !ok {
		err := BatchUpdateGroupStatusRequestValidationError{
			field:  "Status",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BatchUpdateGroupStatusRequestMultiError(errors)
	}

	return nil
}

// BatchUpdateGroupStatusRequestMultiError is an error wrapping multiple
// validation errors returned by BatchUpdateGroupStatusRequest.ValidateAll()
// if the designated constraints aren't met.
type BatchUpdateGroupStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchUpdateGroupStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchUpdateGroupStatusRequestMultiError) AllErrors() []error { return m }

// BatchUpdateGroupStatusRequestValidationError is the validation error
// returned by BatchUpdateGroupStatusRequest.Validate if the designated
// constraints aren't met.
type BatchUpdateGroupStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchUpdateGroupStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchUpdateGroupStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchUpdateGroupStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchUpdateGroupStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchUpdateGroupStatusRequestValidationError) ErrorName() string {
	return "BatchUpdateGroupStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatchUpdateGroupStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchUpdateGroupStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchUpdateGroupStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchUpdateGroupStatusRequestValidationError{}

// Validate checks the field values on BatchUpdateGroupStatusReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchUpdateGroupStatusReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchUpdateGroupStatusReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchUpdateGroupStatusReplyMultiError, or nil if none found.
func (m *BatchUpdateGroupStatusReply) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchUpdateGroupStatusReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BatchUpdateGroupStatusReplyMultiError(errors)
	}

	return nil
}

// BatchUpdateGroupStatusReplyMultiError is an error wrapping multiple
// validation errors returned by BatchUpdateGroupStatusReply.ValidateAll() if
// the designated constraints aren't met.
type BatchUpdateGroupStatusReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchUpdateGroupStatusReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchUpdateGroupStatusReplyMultiError) AllErrors() []error { return m }

// BatchUpdateGroupStatusReplyValidationError is the validation error returned
// by BatchUpdateGroupStatusReply.Validate if the designated constraints
// aren't met.
type BatchUpdateGroupStatusReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchUpdateGroupStatusReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchUpdateGroupStatusReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchUpdateGroupStatusReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchUpdateGroupStatusReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchUpdateGroupStatusReplyValidationError) ErrorName() string {
	return "BatchUpdateGroupStatusReplyValidationError"
}

// Error satisfies the builtin error interface
func (e BatchUpdateGroupStatusReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchUpdateGroupStatusReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchUpdateGroupStatusReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchUpdateGroupStatusReplyValidationError{}

// Validate checks the field values on DeleteGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteGroupRequestMultiError, or nil if none found.
func (m *DeleteGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := DeleteGroupRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteGroupRequestMultiError(errors)
	}

	return nil
}

// DeleteGroupRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteGroupRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteGroupRequestMultiError) AllErrors() []error { return m }

// DeleteGroupRequestValidationError is the validation error returned by
// DeleteGroupRequest.Validate if the designated constraints aren't met.
type DeleteGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteGroupRequestValidationError) ErrorName() string {
	return "DeleteGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteGroupRequestValidationError{}

// Validate checks the field values on DeleteGroupReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteGroupReplyMultiError, or nil if none found.
func (m *DeleteGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteGroupReplyMultiError(errors)
	}

	return nil
}

// DeleteGroupReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteGroupReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteGroupReplyMultiError) AllErrors() []error { return m }

// DeleteGroupReplyValidationError is the validation error returned by
// DeleteGroupReply.Validate if the designated constraints aren't met.
type DeleteGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteGroupReplyValidationError) ErrorName() string { return "DeleteGroupReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeleteGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteGroupReplyValidationError{}

// Validate checks the field values on BatchDeleteGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchDeleteGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchDeleteGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchDeleteGroupRequestMultiError, or nil if none found.
func (m *BatchDeleteGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchDeleteGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetIds()); l < 1 || l > 100 {
		err := BatchDeleteGroupRequestValidationError{
			field:  "Ids",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_BatchDeleteGroupRequest_Ids_Unique := make(map[uint32]struct{}, len(m.GetIds()))

	for idx, item := range m.GetIds() {
		_, _ = idx, item

		if _, exists := _BatchDeleteGroupRequest_Ids_Unique[item]; exists {
			err := BatchDeleteGroupRequestValidationError{
				field:  fmt.Sprintf("Ids[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_BatchDeleteGroupRequest_Ids_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := BatchDeleteGroupRequestValidationError{
				field:  fmt.Sprintf("Ids[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return BatchDeleteGroupRequestMultiError(errors)
	}

	return nil
}

// BatchDeleteGroupRequestMultiError is an error wrapping multiple validation
// errors returned by BatchDeleteGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type BatchDeleteGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchDeleteGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchDeleteGroupRequestMultiError) AllErrors() []error { return m }

// BatchDeleteGroupRequestValidationError is the validation error returned by
// BatchDeleteGroupRequest.Validate if the designated constraints aren't met.
type BatchDeleteGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchDeleteGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchDeleteGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchDeleteGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchDeleteGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchDeleteGroupRequestValidationError) ErrorName() string {
	return "BatchDeleteGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatchDeleteGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchDeleteGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchDeleteGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchDeleteGroupRequestValidationError{}

// Validate checks the field values on BatchDeleteGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchDeleteGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchDeleteGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchDeleteGroupReplyMultiError, or nil if none found.
func (m *BatchDeleteGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchDeleteGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BatchDeleteGroupReplyMultiError(errors)
	}

	return nil
}

// BatchDeleteGroupReplyMultiError is an error wrapping multiple validation
// errors returned by BatchDeleteGroupReply.ValidateAll() if the designated
// constraints aren't met.
type BatchDeleteGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchDeleteGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchDeleteGroupReplyMultiError) AllErrors() []error { return m }

// BatchDeleteGroupReplyValidationError is the validation error returned by
// BatchDeleteGroupReply.Validate if the designated constraints aren't met.
type BatchDeleteGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchDeleteGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchDeleteGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchDeleteGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchDeleteGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchDeleteGroupReplyValidationError) ErrorName() string {
	return "BatchDeleteGroupReplyValidationError"
}

// Error satisfies the builtin error interface
func (e BatchDeleteGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchDeleteGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchDeleteGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchDeleteGroupReplyValidationError{}

// Validate checks the field values on GetGroupRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetGroupRequestMultiError, or nil if none found.
func (m *GetGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetGroupRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetGroupRequestMultiError(errors)
	}

	return nil
}

// GetGroupRequestMultiError is an error wrapping multiple validation errors
// returned by GetGroupRequest.ValidateAll() if the designated constraints
// aren't met.
type GetGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetGroupRequestMultiError) AllErrors() []error { return m }

// GetGroupRequestValidationError is the validation error returned by
// GetGroupRequest.Validate if the designated constraints aren't met.
type GetGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetGroupRequestValidationError) ErrorName() string { return "GetGroupRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetGroupRequestValidationError{}

// Validate checks the field values on GetGroupReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetGroupReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetGroupReplyMultiError, or
// nil if none found.
func (m *GetGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetGroupReplyValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetGroupReplyValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetGroupReplyValidationError{
				field:  "Detail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetGroupReplyMultiError(errors)
	}

	return nil
}

// GetGroupReplyMultiError is an error wrapping multiple validation errors
// returned by GetGroupReply.ValidateAll() if the designated constraints
// aren't met.
type GetGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetGroupReplyMultiError) AllErrors() []error { return m }

// GetGroupReplyValidationError is the validation error returned by
// GetGroupReply.Validate if the designated constraints aren't met.
type GetGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetGroupReplyValidationError) ErrorName() string { return "GetGroupReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetGroupReplyValidationError{}

// Validate checks the field values on ListGroupRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListGroupRequestMultiError, or nil if none found.
func (m *ListGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPage() == nil {
		err := ListGroupRequestValidationError{
			field:  "Page",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListGroupRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListGroupRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListGroupRequestValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetKeyword()) > 32 {
		err := ListGroupRequestValidationError{
			field:  "Keyword",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ListGroupRequest_CategoryIds_Unique := make(map[uint32]struct{}, len(m.GetCategoryIds()))

	for idx, item := range m.GetCategoryIds() {
		_, _ = idx, item

		if _, exists := _ListGroupRequest_CategoryIds_Unique[item]; exists {
			err := ListGroupRequestValidationError{
				field:  fmt.Sprintf("CategoryIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ListGroupRequest_CategoryIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := ListGroupRequestValidationError{
				field:  fmt.Sprintf("CategoryIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := api.Status_name[int32(m.GetStatus())]; !ok {
		err := ListGroupRequestValidationError{
			field:  "Status",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for StartAt

	// no validation rules for EndAt

	if len(errors) > 0 {
		return ListGroupRequestMultiError(errors)
	}

	return nil
}

// ListGroupRequestMultiError is an error wrapping multiple validation errors
// returned by ListGroupRequest.ValidateAll() if the designated constraints
// aren't met.
type ListGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListGroupRequestMultiError) AllErrors() []error { return m }

// ListGroupRequestValidationError is the validation error returned by
// ListGroupRequest.Validate if the designated constraints aren't met.
type ListGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListGroupRequestValidationError) ErrorName() string { return "ListGroupRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListGroupRequestValidationError{}

// Validate checks the field values on ListGroupReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListGroupReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListGroupReplyMultiError,
// or nil if none found.
func (m *ListGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListGroupReplyValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListGroupReplyValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListGroupReplyValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListGroupReplyValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListGroupReplyValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListGroupReplyValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListGroupReplyMultiError(errors)
	}

	return nil
}

// ListGroupReplyMultiError is an error wrapping multiple validation errors
// returned by ListGroupReply.ValidateAll() if the designated constraints
// aren't met.
type ListGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListGroupReplyMultiError) AllErrors() []error { return m }

// ListGroupReplyValidationError is the validation error returned by
// ListGroupReply.Validate if the designated constraints aren't met.
type ListGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListGroupReplyValidationError) ErrorName() string { return "ListGroupReplyValidationError" }

// Error satisfies the builtin error interface
func (e ListGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListGroupReplyValidationError{}

// Validate checks the field values on ListAllGroupDetailRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAllGroupDetailRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAllGroupDetailRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAllGroupDetailRequestMultiError, or nil if none found.
func (m *ListAllGroupDetailRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAllGroupDetailRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListAllGroupDetailRequestMultiError(errors)
	}

	return nil
}

// ListAllGroupDetailRequestMultiError is an error wrapping multiple validation
// errors returned by ListAllGroupDetailRequest.ValidateAll() if the
// designated constraints aren't met.
type ListAllGroupDetailRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAllGroupDetailRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAllGroupDetailRequestMultiError) AllErrors() []error { return m }

// ListAllGroupDetailRequestValidationError is the validation error returned by
// ListAllGroupDetailRequest.Validate if the designated constraints aren't met.
type ListAllGroupDetailRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAllGroupDetailRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAllGroupDetailRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAllGroupDetailRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAllGroupDetailRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAllGroupDetailRequestValidationError) ErrorName() string {
	return "ListAllGroupDetailRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAllGroupDetailRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAllGroupDetailRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAllGroupDetailRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAllGroupDetailRequestValidationError{}

// Validate checks the field values on ListAllGroupDetailReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAllGroupDetailReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAllGroupDetailReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAllGroupDetailReplyMultiError, or nil if none found.
func (m *ListAllGroupDetailReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAllGroupDetailReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetGroupList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAllGroupDetailReplyValidationError{
						field:  fmt.Sprintf("GroupList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAllGroupDetailReplyValidationError{
						field:  fmt.Sprintf("GroupList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAllGroupDetailReplyValidationError{
					field:  fmt.Sprintf("GroupList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListAllGroupDetailReplyMultiError(errors)
	}

	return nil
}

// ListAllGroupDetailReplyMultiError is an error wrapping multiple validation
// errors returned by ListAllGroupDetailReply.ValidateAll() if the designated
// constraints aren't met.
type ListAllGroupDetailReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAllGroupDetailReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAllGroupDetailReplyMultiError) AllErrors() []error { return m }

// ListAllGroupDetailReplyValidationError is the validation error returned by
// ListAllGroupDetailReply.Validate if the designated constraints aren't met.
type ListAllGroupDetailReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAllGroupDetailReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAllGroupDetailReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAllGroupDetailReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAllGroupDetailReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAllGroupDetailReplyValidationError) ErrorName() string {
	return "ListAllGroupDetailReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListAllGroupDetailReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAllGroupDetailReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAllGroupDetailReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAllGroupDetailReplyValidationError{}

// Validate checks the field values on SelectGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SelectGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SelectGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SelectGroupRequestMultiError, or nil if none found.
func (m *SelectGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SelectGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPage() == nil {
		err := SelectGroupRequestValidationError{
			field:  "Page",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SelectGroupRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SelectGroupRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SelectGroupRequestValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetKeyword()) > 32 {
		err := SelectGroupRequestValidationError{
			field:  "Keyword",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := api.Status_name[int32(m.GetStatus())]; !ok {
		err := SelectGroupRequestValidationError{
			field:  "Status",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SelectGroupRequestMultiError(errors)
	}

	return nil
}

// SelectGroupRequestMultiError is an error wrapping multiple validation errors
// returned by SelectGroupRequest.ValidateAll() if the designated constraints
// aren't met.
type SelectGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SelectGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SelectGroupRequestMultiError) AllErrors() []error { return m }

// SelectGroupRequestValidationError is the validation error returned by
// SelectGroupRequest.Validate if the designated constraints aren't met.
type SelectGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SelectGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SelectGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SelectGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SelectGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SelectGroupRequestValidationError) ErrorName() string {
	return "SelectGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SelectGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSelectGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SelectGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SelectGroupRequestValidationError{}

// Validate checks the field values on SelectGroupReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SelectGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SelectGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SelectGroupReplyMultiError, or nil if none found.
func (m *SelectGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *SelectGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SelectGroupReplyValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SelectGroupReplyValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SelectGroupReplyValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SelectGroupReplyValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SelectGroupReplyValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SelectGroupReplyValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SelectGroupReplyMultiError(errors)
	}

	return nil
}

// SelectGroupReplyMultiError is an error wrapping multiple validation errors
// returned by SelectGroupReply.ValidateAll() if the designated constraints
// aren't met.
type SelectGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SelectGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SelectGroupReplyMultiError) AllErrors() []error { return m }

// SelectGroupReplyValidationError is the validation error returned by
// SelectGroupReply.Validate if the designated constraints aren't met.
type SelectGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SelectGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SelectGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SelectGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SelectGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SelectGroupReplyValidationError) ErrorName() string { return "SelectGroupReplyValidationError" }

// Error satisfies the builtin error interface
func (e SelectGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSelectGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SelectGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SelectGroupReplyValidationError{}

// Validate checks the field values on ImportGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportGroupRequestMultiError, or nil if none found.
func (m *ImportGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetGroups()); l < 1 || l > 100 {
		err := ImportGroupRequestValidationError{
			field:  "Groups",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetGroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportGroupRequestValidationError{
						field:  fmt.Sprintf("Groups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportGroupRequestValidationError{
						field:  fmt.Sprintf("Groups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportGroupRequestValidationError{
					field:  fmt.Sprintf("Groups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GetDatasourceId() <= 0 {
		err := ImportGroupRequestValidationError{
			field:  "DatasourceId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetDefaultLevel() <= 0 {
		err := ImportGroupRequestValidationError{
			field:  "DefaultLevel",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetDefaultAlarmPageIds()) < 1 {
		err := ImportGroupRequestValidationError{
			field:  "DefaultAlarmPageIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ImportGroupRequest_DefaultAlarmPageIds_Unique := make(map[uint32]struct{}, len(m.GetDefaultAlarmPageIds()))

	for idx, item := range m.GetDefaultAlarmPageIds() {
		_, _ = idx, item

		if _, exists := _ImportGroupRequest_DefaultAlarmPageIds_Unique[item]; exists {
			err := ImportGroupRequestValidationError{
				field:  fmt.Sprintf("DefaultAlarmPageIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ImportGroupRequest_DefaultAlarmPageIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := ImportGroupRequestValidationError{
				field:  fmt.Sprintf("DefaultAlarmPageIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetDefaultCategoryIds()) < 1 {
		err := ImportGroupRequestValidationError{
			field:  "DefaultCategoryIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ImportGroupRequest_DefaultCategoryIds_Unique := make(map[uint32]struct{}, len(m.GetDefaultCategoryIds()))

	for idx, item := range m.GetDefaultCategoryIds() {
		_, _ = idx, item

		if _, exists := _ImportGroupRequest_DefaultCategoryIds_Unique[item]; exists {
			err := ImportGroupRequestValidationError{
				field:  fmt.Sprintf("DefaultCategoryIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ImportGroupRequest_DefaultCategoryIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := ImportGroupRequestValidationError{
				field:  fmt.Sprintf("DefaultCategoryIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetDefaultAlarmNotifyIds()) < 1 {
		err := ImportGroupRequestValidationError{
			field:  "DefaultAlarmNotifyIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ImportGroupRequest_DefaultAlarmNotifyIds_Unique := make(map[uint32]struct{}, len(m.GetDefaultAlarmNotifyIds()))

	for idx, item := range m.GetDefaultAlarmNotifyIds() {
		_, _ = idx, item

		if _, exists := _ImportGroupRequest_DefaultAlarmNotifyIds_Unique[item]; exists {
			err := ImportGroupRequestValidationError{
				field:  fmt.Sprintf("DefaultAlarmNotifyIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ImportGroupRequest_DefaultAlarmNotifyIds_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := ImportGroupRequestValidationError{
				field:  fmt.Sprintf("DefaultAlarmNotifyIds[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ImportGroupRequestMultiError(errors)
	}

	return nil
}

// ImportGroupRequestMultiError is an error wrapping multiple validation errors
// returned by ImportGroupRequest.ValidateAll() if the designated constraints
// aren't met.
type ImportGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportGroupRequestMultiError) AllErrors() []error { return m }

// ImportGroupRequestValidationError is the validation error returned by
// ImportGroupRequest.Validate if the designated constraints aren't met.
type ImportGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportGroupRequestValidationError) ErrorName() string {
	return "ImportGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ImportGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportGroupRequestValidationError{}

// Validate checks the field values on ImportGroupReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ImportGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportGroupReplyMultiError, or nil if none found.
func (m *ImportGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ImportGroupReplyMultiError(errors)
	}

	return nil
}

// ImportGroupReplyMultiError is an error wrapping multiple validation errors
// returned by ImportGroupReply.ValidateAll() if the designated constraints
// aren't met.
type ImportGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportGroupReplyMultiError) AllErrors() []error { return m }

// ImportGroupReplyValidationError is the validation error returned by
// ImportGroupReply.Validate if the designated constraints aren't met.
type ImportGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportGroupReplyValidationError) ErrorName() string { return "ImportGroupReplyValidationError" }

// Error satisfies the builtin error interface
func (e ImportGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportGroupReplyValidationError{}

// Validate checks the field values on ExportGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExportGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExportGroupRequestMultiError, or nil if none found.
func (m *ExportGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetIds()); l < 1 || l > 100 {
		err := ExportGroupRequestValidationError{
			field:  "Ids",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ExportGroupRequest_Ids_Unique := make(map[uint32]struct{}, len(m.GetIds()))

	for idx, item := range m.GetIds() {
		_, _ = idx, item

		if _, exists := _ExportGroupRequest_Ids_Unique[item]; exists {
			err := ExportGroupRequestValidationError{
				field:  fmt.Sprintf("Ids[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ExportGroupRequest_Ids_Unique[item] = struct{}{}
		}

		if item <= 0 {
			err := ExportGroupRequestValidationError{
				field:  fmt.Sprintf("Ids[%v]", idx),
				reason: "value must be greater than 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ExportGroupRequestMultiError(errors)
	}

	return nil
}

// ExportGroupRequestMultiError is an error wrapping multiple validation errors
// returned by ExportGroupRequest.ValidateAll() if the designated constraints
// aren't met.
type ExportGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportGroupRequestMultiError) AllErrors() []error { return m }

// ExportGroupRequestValidationError is the validation error returned by
// ExportGroupRequest.Validate if the designated constraints aren't met.
type ExportGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportGroupRequestValidationError) ErrorName() string {
	return "ExportGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExportGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportGroupRequestValidationError{}

// Validate checks the field values on ExportGroupReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExportGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExportGroupReplyMultiError, or nil if none found.
func (m *ExportGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetGroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExportGroupReplyValidationError{
						field:  fmt.Sprintf("Groups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExportGroupReplyValidationError{
						field:  fmt.Sprintf("Groups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExportGroupReplyValidationError{
					field:  fmt.Sprintf("Groups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExportGroupReplyMultiError(errors)
	}

	return nil
}

// ExportGroupReplyMultiError is an error wrapping multiple validation errors
// returned by ExportGroupReply.ValidateAll() if the designated constraints
// aren't met.
type ExportGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportGroupReplyMultiError) AllErrors() []error { return m }

// ExportGroupReplyValidationError is the validation error returned by
// ExportGroupReply.Validate if the designated constraints aren't met.
type ExportGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportGroupReplyValidationError) ErrorName() string { return "ExportGroupReplyValidationError" }

// Error satisfies the builtin error interface
func (e ExportGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportGroupReplyValidationError{}
