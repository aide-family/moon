// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.5.3
// - protoc             v3.19.4
// source: server/prom/strategy/group/group.proto

package group

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationGroupBatchDeleteGroup = "/api.server.prom.strategy.group.Group/BatchDeleteGroup"
const OperationGroupBatchUpdateGroupStatus = "/api.server.prom.strategy.group.Group/BatchUpdateGroupStatus"
const OperationGroupCreateGroup = "/api.server.prom.strategy.group.Group/CreateGroup"
const OperationGroupDeleteGroup = "/api.server.prom.strategy.group.Group/DeleteGroup"
const OperationGroupExportGroup = "/api.server.prom.strategy.group.Group/ExportGroup"
const OperationGroupGetGroup = "/api.server.prom.strategy.group.Group/GetGroup"
const OperationGroupImportGroup = "/api.server.prom.strategy.group.Group/ImportGroup"
const OperationGroupListAllGroupDetail = "/api.server.prom.strategy.group.Group/ListAllGroupDetail"
const OperationGroupListGroup = "/api.server.prom.strategy.group.Group/ListGroup"
const OperationGroupSelectGroup = "/api.server.prom.strategy.group.Group/SelectGroup"
const OperationGroupUpdateGroup = "/api.server.prom.strategy.group.Group/UpdateGroup"

type GroupHTTPServer interface {
	BatchDeleteGroup(context.Context, *BatchDeleteGroupRequest) (*BatchDeleteGroupReply, error)
	BatchUpdateGroupStatus(context.Context, *BatchUpdateGroupStatusRequest) (*BatchUpdateGroupStatusReply, error)
	CreateGroup(context.Context, *CreateGroupRequest) (*CreateGroupReply, error)
	DeleteGroup(context.Context, *DeleteGroupRequest) (*DeleteGroupReply, error)
	ExportGroup(context.Context, *ExportGroupRequest) (*ExportGroupReply, error)
	GetGroup(context.Context, *GetGroupRequest) (*GetGroupReply, error)
	ImportGroup(context.Context, *ImportGroupRequest) (*ImportGroupReply, error)
	ListAllGroupDetail(context.Context, *ListAllGroupDetailRequest) (*ListAllGroupDetailReply, error)
	ListGroup(context.Context, *ListGroupRequest) (*ListGroupReply, error)
	SelectGroup(context.Context, *SelectGroupRequest) (*SelectGroupReply, error)
	UpdateGroup(context.Context, *UpdateGroupRequest) (*UpdateGroupReply, error)
}

func RegisterGroupHTTPServer(s *http.Server, srv GroupHTTPServer) {
	r := s.Route("/")
	r.POST("/api/v1/strategy/group/create", _Group_CreateGroup0_HTTP_Handler(srv))
	r.POST("/api/v1/strategy/group/update", _Group_UpdateGroup0_HTTP_Handler(srv))
	r.POST("/api/v1/strategy/group/status/batch/update", _Group_BatchUpdateGroupStatus0_HTTP_Handler(srv))
	r.POST("/api/v1/strategy/group/delete", _Group_DeleteGroup0_HTTP_Handler(srv))
	r.POST("/api/v1/strategy/group/batch/delete", _Group_BatchDeleteGroup0_HTTP_Handler(srv))
	r.POST("/api/v1/strategy/group/get", _Group_GetGroup0_HTTP_Handler(srv))
	r.POST("/api/v1/strategy/group/list", _Group_ListGroup0_HTTP_Handler(srv))
	r.POST("/api/v1/strategy/group/all/list", _Group_ListAllGroupDetail0_HTTP_Handler(srv))
	r.POST("/api/v1/strategy/group/select", _Group_SelectGroup0_HTTP_Handler(srv))
	r.POST("/api/v1/strategy/group/import", _Group_ImportGroup0_HTTP_Handler(srv))
	r.POST("/api/v1/strategy/group/export", _Group_ExportGroup0_HTTP_Handler(srv))
}

func _Group_CreateGroup0_HTTP_Handler(srv GroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateGroupRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGroupCreateGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateGroup(ctx, req.(*CreateGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateGroupReply)
		return ctx.Result(200, reply)
	}
}

func _Group_UpdateGroup0_HTTP_Handler(srv GroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateGroupRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGroupUpdateGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateGroup(ctx, req.(*UpdateGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateGroupReply)
		return ctx.Result(200, reply)
	}
}

func _Group_BatchUpdateGroupStatus0_HTTP_Handler(srv GroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BatchUpdateGroupStatusRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGroupBatchUpdateGroupStatus)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BatchUpdateGroupStatus(ctx, req.(*BatchUpdateGroupStatusRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BatchUpdateGroupStatusReply)
		return ctx.Result(200, reply)
	}
}

func _Group_DeleteGroup0_HTTP_Handler(srv GroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteGroupRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGroupDeleteGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteGroup(ctx, req.(*DeleteGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteGroupReply)
		return ctx.Result(200, reply)
	}
}

func _Group_BatchDeleteGroup0_HTTP_Handler(srv GroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BatchDeleteGroupRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGroupBatchDeleteGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BatchDeleteGroup(ctx, req.(*BatchDeleteGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BatchDeleteGroupReply)
		return ctx.Result(200, reply)
	}
}

func _Group_GetGroup0_HTTP_Handler(srv GroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetGroupRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGroupGetGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetGroup(ctx, req.(*GetGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetGroupReply)
		return ctx.Result(200, reply)
	}
}

func _Group_ListGroup0_HTTP_Handler(srv GroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListGroupRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGroupListGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListGroup(ctx, req.(*ListGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListGroupReply)
		return ctx.Result(200, reply)
	}
}

func _Group_ListAllGroupDetail0_HTTP_Handler(srv GroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListAllGroupDetailRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGroupListAllGroupDetail)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListAllGroupDetail(ctx, req.(*ListAllGroupDetailRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListAllGroupDetailReply)
		return ctx.Result(200, reply)
	}
}

func _Group_SelectGroup0_HTTP_Handler(srv GroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SelectGroupRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGroupSelectGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SelectGroup(ctx, req.(*SelectGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SelectGroupReply)
		return ctx.Result(200, reply)
	}
}

func _Group_ImportGroup0_HTTP_Handler(srv GroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ImportGroupRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGroupImportGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ImportGroup(ctx, req.(*ImportGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ImportGroupReply)
		return ctx.Result(200, reply)
	}
}

func _Group_ExportGroup0_HTTP_Handler(srv GroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ExportGroupRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGroupExportGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ExportGroup(ctx, req.(*ExportGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ExportGroupReply)
		return ctx.Result(200, reply)
	}
}

type GroupHTTPClient interface {
	BatchDeleteGroup(ctx context.Context, req *BatchDeleteGroupRequest, opts ...http.CallOption) (rsp *BatchDeleteGroupReply, err error)
	BatchUpdateGroupStatus(ctx context.Context, req *BatchUpdateGroupStatusRequest, opts ...http.CallOption) (rsp *BatchUpdateGroupStatusReply, err error)
	CreateGroup(ctx context.Context, req *CreateGroupRequest, opts ...http.CallOption) (rsp *CreateGroupReply, err error)
	DeleteGroup(ctx context.Context, req *DeleteGroupRequest, opts ...http.CallOption) (rsp *DeleteGroupReply, err error)
	ExportGroup(ctx context.Context, req *ExportGroupRequest, opts ...http.CallOption) (rsp *ExportGroupReply, err error)
	GetGroup(ctx context.Context, req *GetGroupRequest, opts ...http.CallOption) (rsp *GetGroupReply, err error)
	ImportGroup(ctx context.Context, req *ImportGroupRequest, opts ...http.CallOption) (rsp *ImportGroupReply, err error)
	ListAllGroupDetail(ctx context.Context, req *ListAllGroupDetailRequest, opts ...http.CallOption) (rsp *ListAllGroupDetailReply, err error)
	ListGroup(ctx context.Context, req *ListGroupRequest, opts ...http.CallOption) (rsp *ListGroupReply, err error)
	SelectGroup(ctx context.Context, req *SelectGroupRequest, opts ...http.CallOption) (rsp *SelectGroupReply, err error)
	UpdateGroup(ctx context.Context, req *UpdateGroupRequest, opts ...http.CallOption) (rsp *UpdateGroupReply, err error)
}

type GroupHTTPClientImpl struct {
	cc *http.Client
}

func NewGroupHTTPClient(client *http.Client) GroupHTTPClient {
	return &GroupHTTPClientImpl{client}
}

func (c *GroupHTTPClientImpl) BatchDeleteGroup(ctx context.Context, in *BatchDeleteGroupRequest, opts ...http.CallOption) (*BatchDeleteGroupReply, error) {
	var out BatchDeleteGroupReply
	pattern := "/api/v1/strategy/group/batch/delete"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGroupBatchDeleteGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GroupHTTPClientImpl) BatchUpdateGroupStatus(ctx context.Context, in *BatchUpdateGroupStatusRequest, opts ...http.CallOption) (*BatchUpdateGroupStatusReply, error) {
	var out BatchUpdateGroupStatusReply
	pattern := "/api/v1/strategy/group/status/batch/update"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGroupBatchUpdateGroupStatus))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GroupHTTPClientImpl) CreateGroup(ctx context.Context, in *CreateGroupRequest, opts ...http.CallOption) (*CreateGroupReply, error) {
	var out CreateGroupReply
	pattern := "/api/v1/strategy/group/create"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGroupCreateGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GroupHTTPClientImpl) DeleteGroup(ctx context.Context, in *DeleteGroupRequest, opts ...http.CallOption) (*DeleteGroupReply, error) {
	var out DeleteGroupReply
	pattern := "/api/v1/strategy/group/delete"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGroupDeleteGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GroupHTTPClientImpl) ExportGroup(ctx context.Context, in *ExportGroupRequest, opts ...http.CallOption) (*ExportGroupReply, error) {
	var out ExportGroupReply
	pattern := "/api/v1/strategy/group/export"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGroupExportGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GroupHTTPClientImpl) GetGroup(ctx context.Context, in *GetGroupRequest, opts ...http.CallOption) (*GetGroupReply, error) {
	var out GetGroupReply
	pattern := "/api/v1/strategy/group/get"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGroupGetGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GroupHTTPClientImpl) ImportGroup(ctx context.Context, in *ImportGroupRequest, opts ...http.CallOption) (*ImportGroupReply, error) {
	var out ImportGroupReply
	pattern := "/api/v1/strategy/group/import"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGroupImportGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GroupHTTPClientImpl) ListAllGroupDetail(ctx context.Context, in *ListAllGroupDetailRequest, opts ...http.CallOption) (*ListAllGroupDetailReply, error) {
	var out ListAllGroupDetailReply
	pattern := "/api/v1/strategy/group/all/list"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGroupListAllGroupDetail))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GroupHTTPClientImpl) ListGroup(ctx context.Context, in *ListGroupRequest, opts ...http.CallOption) (*ListGroupReply, error) {
	var out ListGroupReply
	pattern := "/api/v1/strategy/group/list"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGroupListGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GroupHTTPClientImpl) SelectGroup(ctx context.Context, in *SelectGroupRequest, opts ...http.CallOption) (*SelectGroupReply, error) {
	var out SelectGroupReply
	pattern := "/api/v1/strategy/group/select"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGroupSelectGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *GroupHTTPClientImpl) UpdateGroup(ctx context.Context, in *UpdateGroupRequest, opts ...http.CallOption) (*UpdateGroupReply, error) {
	var out UpdateGroupReply
	pattern := "/api/v1/strategy/group/update"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGroupUpdateGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
